<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 02: FiÈ™iere Text Ã®n C | ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
            z-index: 1000;
        }

        /* Slide Container */
        .slides-container {
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }

        /* Typography */
        h1 {
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            font-size: 2.2rem;
            font-weight: 600;
            margin-bottom: 30px;
            color: var(--accent-blue);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 15px;
        }

        h3 {
            font-size: 1.6rem;
            font-weight: 600;
            margin: 20px 0 15px;
            color: var(--accent-green);
        }

        p {
            font-size: 1.25rem;
            line-height: 1.8;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        /* Lists */
        ul, ol {
            margin: 15px 0 15px 30px;
            font-size: 1.2rem;
            line-height: 1.9;
        }

        li {
            margin-bottom: 12px;
        }

        li::marker {
            color: var(--accent-blue);
        }

        /* Code Blocks */
        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 3px 10px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .code-block pre {
            margin: 0;
            padding: 20px;
            overflow-x: auto;
        }

        .code-block code {
            font-family: 'Fira Code', 'JetBrains Mono', 'Consolas', monospace;
            font-size: 1rem;
            line-height: 1.6;
        }

        /* Inline code */
        code:not([class*="language-"]) {
            background: var(--bg-tertiary);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            font-size: 0.95em;
            color: var(--accent-yellow);
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1.05rem;
        }

        th, td {
            padding: 14px 18px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Boxes */
        .info-box {
            background: rgba(88, 166, 255, 0.1);
            border-left: 4px solid var(--accent-blue);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .warning-box {
            background: rgba(210, 153, 34, 0.1);
            border-left: 4px solid var(--accent-yellow);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .danger-box {
            background: rgba(248, 81, 73, 0.1);
            border-left: 4px solid var(--accent-red);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .success-box {
            background: rgba(63, 185, 80, 0.1);
            border-left: 4px solid var(--accent-green);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        /* Grid layouts */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin: 20px 0;
        }

        .three-columns {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
            margin: 20px 0;
        }

        .column {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* Cards */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 25px;
            transition: transform 0.2s, border-color 0.2s;
        }

        .card:hover {
            transform: translateY(-3px);
            border-color: var(--accent-blue);
        }

        .card h4 {
            color: var(--accent-blue);
            font-size: 1.2rem;
            margin-bottom: 12px;
        }

        .card p {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 0;
        }

        /* Title Slide */
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .title-slide h1 {
            font-size: 3.5rem;
            margin-bottom: 30px;
        }

        .title-slide .subtitle {
            font-size: 1.8rem;
            color: var(--text-secondary);
            margin-bottom: 40px;
        }

        .title-slide .meta {
            font-size: 1.2rem;
            color: var(--text-secondary);
        }

        /* Quote styling */
        blockquote {
            border-left: 4px solid var(--accent-purple);
            padding: 20px 30px;
            margin: 25px 0;
            background: var(--bg-secondary);
            border-radius: 0 8px 8px 0;
            font-style: italic;
            font-size: 1.2rem;
        }

        blockquote cite {
            display: block;
            margin-top: 15px;
            font-style: normal;
            color: var(--accent-purple);
            font-size: 1rem;
        }

        /* ASCII Diagram */
        .ascii-diagram {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 25px;
            font-family: 'Fira Code', monospace;
            font-size: 0.95rem;
            line-height: 1.4;
            white-space: pre;
            overflow-x: auto;
            color: var(--accent-green);
        }

        /* Navigation */
        .nav-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        /* Slide counter */
        .slide-counter {
            position: fixed;
            bottom: 30px;
            left: 30px;
            font-size: 1rem;
            color: var(--text-secondary);
            z-index: 1000;
        }

        /* Figure styling */
        .figure-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
        }

        .figure-box .portrait {
            width: 150px;
            height: 150px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
        }

        .figure-box h4 {
            color: var(--accent-blue);
            font-size: 1.4rem;
            margin-bottom: 8px;
        }

        .figure-box .years {
            color: var(--text-secondary);
            font-size: 1rem;
            margin-bottom: 15px;
        }

        /* Keyboard hints */
        kbd {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 3px 8px;
            font-family: monospace;
            font-size: 0.9em;
        }

        /* Highlight effect */
        .highlight {
            color: var(--accent-yellow);
            font-weight: 600;
        }

        .highlight-blue {
            color: var(--accent-blue);
        }

        .highlight-green {
            color: var(--accent-green);
        }

        .highlight-red {
            color: var(--accent-red);
        }

        /* Emoji styling */
        .emoji {
            font-size: 1.3em;
            margin-right: 8px;
        }

        /* Summary grid */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .summary-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .summary-item .icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
        }

        .summary-item h4 {
            color: var(--accent-blue);
            margin-bottom: 10px;
        }

        /* Do/Don't columns */
        .do-dont {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .do-column {
            border: 2px solid var(--accent-green);
            border-radius: 8px;
            padding: 25px;
        }

        .do-column h4 {
            color: var(--accent-green);
            margin-bottom: 15px;
        }

        .dont-column {
            border: 2px solid var(--accent-red);
            border-radius: 8px;
            padding: 25px;
        }

        .dont-column h4 {
            color: var(--accent-red);
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>
    
    <div class="slides-container" id="slidesContainer">
        
        <!-- Slide 1: Title -->
        <div class="slide title-slide active" data-slide="1">
            <h1>ğŸ—‚ï¸ FiÈ™iere Text Ã®n C</h1>
            <p class="subtitle">SÄƒptÄƒmÃ¢na 02 | Algoritmi È™i Tehnici de Programare</p>
            <p class="meta">Academia de Studii Economice BucureÈ™ti<br>Facultatea CSIE</p>
            <p style="margin-top: 50px; font-size: 1rem; color: var(--text-secondary);">
                Navigare: <kbd>â†</kbd> <kbd>â†’</kbd> sau <kbd>Space</kbd> | 
                <kbd>Home</kbd> <kbd>End</kbd> pentru Ã®nceput/final
            </p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide" data-slide="2">
            <h2>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h2>
            <ul>
                <li><strong>RecunoaÈ™te</strong> diferitele moduri de deschidere a fiÈ™ierelor (<code>"r"</code>, <code>"w"</code>, <code>"a"</code>, <code>"r+"</code>, etc.) È™i implicaÈ›iile fiecÄƒruia</li>
                <li><strong>ÃnÈ›elege</strong> mecanismul de buffering Ã®n operaÈ›iile I/O È™i diferenÈ›ele dintre stream-uri</li>
                <li><strong>AplicÄƒ</strong> funcÈ›iile standard: <code>fopen</code>, <code>fclose</code>, <code>fgets</code>, <code>fputs</code>, <code>fprintf</code>, <code>fscanf</code></li>
                <li><strong>AnalizeazÄƒ</strong> structura datelor din fiÈ™iere text complexe (CSV, INI, log-uri)</li>
                <li><strong>EvalueazÄƒ</strong> diverse abordÄƒri de procesare È™i alege strategia optimÄƒ</li>
                <li><strong>CreeazÄƒ</strong> aplicaÈ›ii complete pentru procesarea seturilor mari de date structurate</li>
            </ul>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide" data-slide="3">
            <h2>ğŸ“œ Context Istoric</h2>
            <div class="two-columns">
                <div>
                    <h3>Cronologie</h3>
                    <ul>
                        <li><strong>1969</strong> - UNIX dezvoltat la Bell Labs</li>
                        <li><strong>1972</strong> - Limbajul C creat de Dennis Ritchie</li>
                        <li><strong>1973</strong> - Biblioteca <code>stdio</code> dezvoltatÄƒ</li>
                        <li><strong>1978</strong> - K&R "The C Programming Language"</li>
                        <li><strong>1989</strong> - Standardul ANSI C (C89)</li>
                        <li><strong>1999</strong> - Standardul C99</li>
                        <li><strong>2011</strong> - Standardul C11 (actual)</li>
                    </ul>
                </div>
                <div>
                    <h3>Filosofia UNIX</h3>
                    <blockquote>
                        "Everything is a file"
                        <cite>â€” Filosofia UNIX</cite>
                    </blockquote>
                    <p>AceastÄƒ abstracÈ›ie unificatoare permite tratarea uniformÄƒ a:</p>
                    <ul>
                        <li>FiÈ™ierelor obiÈ™nuite</li>
                        <li>Directoarelor</li>
                        <li>Dispozitivelor hardware</li>
                        <li>Conexiunilor de reÈ›ea</li>
                        <li>Pipe-urilor È™i socket-urilor</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 4: Key Figure - Dennis Ritchie -->
        <div class="slide" data-slide="4">
            <h2>ğŸ‘¤ FigurÄƒ Cheie: Dennis Ritchie</h2>
            <div class="two-columns">
                <div class="figure-box">
                    <div class="portrait">ğŸ‘¨â€ğŸ’»</div>
                    <h4>Dennis MacAlistair Ritchie</h4>
                    <p class="years">1941 - 2011</p>
                    <p>Creatorul limbajului C È™i co-developer al sistemului UNIX</p>
                </div>
                <div>
                    <h3>ContribuÈ›ii majore</h3>
                    <ul>
                        <li>Limbajul de programare C (1972)</li>
                        <li>Sistemul de operare UNIX (cu Ken Thompson)</li>
                        <li>Biblioteca standard <code>stdio</code></li>
                        <li>Conceptul de stream È™i FILE*</li>
                    </ul>
                    
                    <blockquote>
                        "UNIX is very simple, it just needs a genius to understand its simplicity."
                        <cite>â€” Dennis Ritchie</cite>
                    </blockquote>
                    
                    <h3>DistincÈ›ii</h3>
                    <ul>
                        <li>ğŸ† Premiul Turing (1983)</li>
                        <li>ğŸ–ï¸ Medalia NaÈ›ionalÄƒ pentru Tehnologie (1998)</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 5: What is a Stream? -->
        <div class="slide" data-slide="5">
            <h2>ğŸ“¡ Ce este un Stream?</h2>
            <div class="info-box">
                <p><strong>DefiniÈ›ie:</strong> Un stream (flux de date) este o abstracÈ›ie care permite programelor sÄƒ interacÈ›ioneze uniform cu diverse surse È™i destinaÈ›ii de date.</p>
            </div>
            <div class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ABSTRACÈšIA STREAM                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   Program C              Stream (FILE*)              DestinaÈ›ie              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚         â”‚  fprintf   â”‚             â”‚   write    â”‚  FiÈ™ier     â”‚           â”‚
â”‚  â”‚ Codul   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚   Buffer    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  Terminal   â”‚           â”‚
â”‚  â”‚ SursÄƒ   â”‚            â”‚   intern    â”‚            â”‚  Socket     â”‚           â”‚
â”‚  â”‚         â”‚  fscanf    â”‚             â”‚   read     â”‚  Pipe       â”‚           â”‚
â”‚  â”‚         â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚             â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚  Device     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                                              â”‚
â”‚   Avantaje: Portabilitate, Buffering automat, InterfaÈ›Äƒ uniformÄƒ            â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- Slide 6: Standard Streams -->
        <div class="slide" data-slide="6">
            <h2>ğŸ“¥ğŸ“¤ Stream-uri Standard</h2>
            <p>Fiecare program C are trei stream-uri predefinite, deschise automat:</p>
            <table>
                <tr>
                    <th>Stream</th>
                    <th>VariabilÄƒ</th>
                    <th>fd</th>
                    <th>DirecÈ›ie</th>
                    <th>Buffering implicit</th>
                </tr>
                <tr>
                    <td>Standard Input</td>
                    <td><code>stdin</code></td>
                    <td>0</td>
                    <td>Intrare</td>
                    <td>Line buffered (terminal)</td>
                </tr>
                <tr>
                    <td>Standard Output</td>
                    <td><code>stdout</code></td>
                    <td>1</td>
                    <td>IeÈ™ire</td>
                    <td>Line buffered (terminal)</td>
                </tr>
                <tr>
                    <td>Standard Error</td>
                    <td><code>stderr</code></td>
                    <td>2</td>
                    <td>IeÈ™ire</td>
                    <td>Unbuffered</td>
                </tr>
            </table>
            <div class="code-block">
                <div class="code-header">
                    <span>Utilizare stream-uri standard</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* stdin: citire de la tastaturÄƒ */
char buffer[100];
fgets(buffer, sizeof(buffer), stdin);

/* stdout: afiÈ™are normalÄƒ */
fprintf(stdout, "Rezultat: %d\n", valoare);

/* stderr: mesaje de eroare (nu trec prin buffer) */
fprintf(stderr, "Eroare: fiÈ™ierul nu existÄƒ!\n");</code></pre>
            </div>
        </div>

        <!-- Slide 7: FILE Structure -->
        <div class="slide" data-slide="7">
            <h2>ğŸ—ï¸ Structura FILE (Internals)</h2>
            <p>Structura <code>FILE</code> este definitÄƒ Ã®n <code>&lt;stdio.h&gt;</code> È™i conÈ›ine informaÈ›ii despre stream:</p>
            <div class="two-columns">
                <div class="code-block">
                    <div class="code-header">
                        <span>Structura FILE (simplificatÄƒ)</span>
                        <span class="lang-badge">C</span>
                    </div>
                    <pre><code class="language-c">/* Implementare conceptualÄƒ */
typedef struct {
    int   _fd;       /* file descriptor */
    char* _base;     /* baza buffer-ului */
    char* _ptr;      /* poziÈ›ie curentÄƒ */
    int   _cnt;      /* caractere rÄƒmase */
    int   _bufsiz;   /* dimensiune buffer */
    int   _flag;     /* stare stream */
} FILE;</code></pre>
                </div>
                <div>
                    <h3>CÃ¢mpuri importante</h3>
                    <ul>
                        <li><code>_fd</code> - file descriptor pentru apeluri sistem</li>
                        <li><code>_base</code> - pointer la Ã®nceputul buffer-ului</li>
                        <li><code>_ptr</code> - poziÈ›ia curentÄƒ de citire/scriere</li>
                        <li><code>_cnt</code> - bytes disponibili Ã®n buffer</li>
                        <li><code>_flag</code> - flags: EOF, ERROR, READ, WRITE</li>
                    </ul>
                    <div class="warning-box">
                        <strong>âš ï¸ AtenÈ›ie:</strong> Nu accesaÈ›i niciodatÄƒ direct membrii structurii FILE! FolosiÈ›i doar funcÈ›iile standard.
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 8: Opening Files - fopen() -->
        <div class="slide" data-slide="8">
            <h2>ğŸ“‚ Deschiderea FiÈ™ierelor: fopen()</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Sintaxa funcÈ›iei fopen()</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">FILE *fopen(const char *filename, const char *mode);

/* Exemplu de utilizare */
FILE *fp = fopen("date.txt", "r");

if (fp == NULL) {
    perror("Eroare la deschidere");
    exit(EXIT_FAILURE);
}

/* ... operaÈ›ii cu fiÈ™ierul ... */

fclose(fp);  /* OBLIGATORIU! */</code></pre>
            </div>
            <div class="info-box">
                <p><strong>ReturneazÄƒ:</strong></p>
                <ul>
                    <li><span class="highlight-green">Succes:</span> Pointer cÄƒtre structura FILE</li>
                    <li><span class="highlight-red">Eroare:</span> NULL (verificÄƒ <code>errno</code> pentru detalii)</li>
                </ul>
            </div>
        </div>

        <!-- Slide 9: File Opening Modes -->
        <div class="slide" data-slide="9">
            <h2>ğŸ” Moduri de Deschidere</h2>
            <table>
                <tr>
                    <th>Mod</th>
                    <th>Descriere</th>
                    <th>FiÈ™ier existÄƒ</th>
                    <th>Nu existÄƒ</th>
                    <th>PoziÈ›ie</th>
                </tr>
                <tr>
                    <td><code>"r"</code></td>
                    <td>Read only</td>
                    <td>Deschide</td>
                    <td class="highlight-red">Eroare</td>
                    <td>Ãnceput</td>
                </tr>
                <tr>
                    <td><code>"w"</code></td>
                    <td>Write only</td>
                    <td class="highlight-yellow">È˜terge conÈ›inut!</td>
                    <td>CreeazÄƒ</td>
                    <td>Ãnceput</td>
                </tr>
                <tr>
                    <td><code>"a"</code></td>
                    <td>Append</td>
                    <td>PÄƒstreazÄƒ</td>
                    <td>CreeazÄƒ</td>
                    <td>SfÃ¢rÈ™it</td>
                </tr>
                <tr>
                    <td><code>"r+"</code></td>
                    <td>Read + Write</td>
                    <td>Deschide</td>
                    <td class="highlight-red">Eroare</td>
                    <td>Ãnceput</td>
                </tr>
                <tr>
                    <td><code>"w+"</code></td>
                    <td>Write + Read</td>
                    <td class="highlight-yellow">È˜terge conÈ›inut!</td>
                    <td>CreeazÄƒ</td>
                    <td>Ãnceput</td>
                </tr>
                <tr>
                    <td><code>"a+"</code></td>
                    <td>Append + Read</td>
                    <td>PÄƒstreazÄƒ</td>
                    <td>CreeazÄƒ</td>
                    <td>SfÃ¢rÈ™it (scriere)</td>
                </tr>
            </table>
            <div class="danger-box">
                <strong>ğŸš¨ AtenÈ›ie:</strong> Modul <code>"w"</code> È™terge IRECUPERABIL conÈ›inutul fiÈ™ierului existent!
            </div>
        </div>

        <!-- Slide 10: Closing Files - fclose() -->
        <div class="slide" data-slide="10">
            <h2>ğŸ”’ Ãnchiderea FiÈ™ierelor: fclose()</h2>
            <div class="two-columns">
                <div>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Sintaxa È™i utilizare</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">int fclose(FILE *stream);

/* ReturneazÄƒ:
 * 0      - succes
 * EOF    - eroare
 */

FILE *fp = fopen("date.txt", "w");
if (fp != NULL) {
    fprintf(fp, "Test\n");
    
    if (fclose(fp) != 0) {
        perror("Eroare la Ã®nchidere");
    }
}</code></pre>
                    </div>
                </div>
                <div>
                    <h3>Ce face fclose()?</h3>
                    <ol>
                        <li>GoleÈ™te (flush) buffer-ul pe disc</li>
                        <li>ElibereazÄƒ buffer-ul din memorie</li>
                        <li>Ãnchide file descriptor-ul</li>
                        <li>ElibereazÄƒ structura FILE</li>
                    </ol>
                    <div class="danger-box">
                        <h4>ConsecinÈ›e dacÄƒ NU apelezi fclose():</h4>
                        <ul>
                            <li>Date pierdute (buffer nescris)</li>
                            <li>File descriptors epuizaÈ›i</li>
                            <li>Memory leaks</li>
                            <li>CorupÈ›ie la crash</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 11: Error Handling Pattern -->
        <div class="slide" data-slide="11">
            <h2>âš ï¸ Pattern-ul Standard pentru Gestionarea Erorilor</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Pattern recomandat pentru operaÈ›ii cu fiÈ™iere</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

int process_file(const char *filename) {
    FILE *fp = fopen(filename, "r");
    
    if (fp == NULL) {
        /* errno conÈ›ine codul de eroare */
        fprintf(stderr, "Nu pot deschide '%s': %s\n", 
                filename, strerror(errno));
        return -1;
    }
    
    /* Procesare fiÈ™ier */
    char line[256];
    while (fgets(line, sizeof(line), fp) != NULL) {
        /* ProceseazÄƒ linia */
        printf("%s", line);
    }
    
    /* VerificÄƒ dacÄƒ bucla s-a terminat din cauza unei erori */
    if (ferror(fp)) {
        fprintf(stderr, "Eroare la citire: %s\n", strerror(errno));
        fclose(fp);
        return -1;
    }
    
    fclose(fp);
    return 0;
}</code></pre>
            </div>
        </div>

        <!-- Slide 12: Buffering Types -->
        <div class="slide" data-slide="12">
            <h2>ğŸš¿ Tipuri de Buffering</h2>
            <div class="three-columns">
                <div class="column">
                    <h3 style="color: var(--accent-blue);">Full Buffered</h3>
                    <p><code>_IOFBF</code></p>
                    <p>Datele sunt scrise pe disc doar cÃ¢nd buffer-ul este plin.</p>
                    <ul>
                        <li>âœ… PerformanÈ›Äƒ maximÄƒ</li>
                        <li>âœ… Minim apeluri sistem</li>
                        <li>âš ï¸ Vizibilitate Ã®ntÃ¢rziatÄƒ</li>
                    </ul>
                    <p><strong>Utilizare:</strong> FiÈ™iere pe disc</p>
                </div>
                <div class="column">
                    <h3 style="color: var(--accent-green);">Line Buffered</h3>
                    <p><code>_IOLBF</code></p>
                    <p>Datele sunt scrise la fiecare newline (<code>\n</code>).</p>
                    <ul>
                        <li>âœ… Compromis bun</li>
                        <li>âœ… Output lizibil</li>
                        <li>âš ï¸ PerformanÈ›Äƒ medie</li>
                    </ul>
                    <p><strong>Utilizare:</strong> stdout (terminal)</p>
                </div>
                <div class="column">
                    <h3 style="color: var(--accent-red);">Unbuffered</h3>
                    <p><code>_IONBF</code></p>
                    <p>Fiecare operaÈ›ie genereazÄƒ un apel sistem imediat.</p>
                    <ul>
                        <li>âœ… Vizibilitate imediatÄƒ</li>
                        <li>âœ… Fiabil pentru erori</li>
                        <li>âŒ Overhead mare</li>
                    </ul>
                    <p><strong>Utilizare:</strong> stderr</p>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Configurarea buffering-ului</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Dezactivare buffering (output imediat) */
setvbuf(stdout, NULL, _IONBF, 0);

/* Buffer personalizat de 16KB pentru fiÈ™ier */
char mybuf[16384];
setvbuf(fp, mybuf, _IOFBF, sizeof(mybuf));

/* ForÈ›are scriere buffer pe disc */
fflush(fp);  /* sau fflush(NULL) pentru toate */</code></pre>
            </div>
        </div>

        <!-- Slide 13: Reading Functions Overview -->
        <div class="slide" data-slide="13">
            <h2>ğŸ“– FuncÈ›ii de Citire - Vedere de Ansamblu</h2>
            <div class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      IERARHIA FUNCÈšIILOR DE CITIRE                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   ğŸ”¹ NIVEL ÃNALT (Formatat)                                                  â”‚
â”‚   â”œâ”€â”€ fscanf(fp, format, ...)    â”€ citire formatatÄƒ din stream               â”‚
â”‚   â””â”€â”€ scanf(format, ...)         â”€ echivalent fscanf(stdin, ...)             â”‚
â”‚                                                                              â”‚
â”‚   ğŸ”¸ NIVEL MEDIU (Linie/String)                                              â”‚
â”‚   â”œâ”€â”€ fgets(buf, n, fp)   â”€ RECOMANDAT! Sigur, citeÈ™te maxim n-1 chars       â”‚
â”‚   â”œâ”€â”€ gets(buf)           â”€ âš ï¸ DEPRECIAT! Nu folosiÈ›i niciodatÄƒ!             â”‚
â”‚   â””â”€â”€ getline(&buf, &n, fp) â”€ POSIX, alocare dinamicÄƒ                        â”‚
â”‚                                                                              â”‚
â”‚   ğŸ”» NIVEL SCÄ‚ZUT (Caracter)                                                 â”‚
â”‚   â”œâ”€â”€ fgetc(fp)           â”€ citeÈ™te un caracter din stream                   â”‚
â”‚   â”œâ”€â”€ getc(fp)            â”€ macro, echivalent cu fgetc                       â”‚
â”‚   â””â”€â”€ getchar()           â”€ echivalent getc(stdin)                           â”‚
â”‚                                                                              â”‚
â”‚   ğŸ“Œ RECOMANDARE: FolosiÈ›i fgets() pentru majoritatea cazurilor!             â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- Slide 14: fgets() - The Safe Choice -->
        <div class="slide" data-slide="14">
            <h2>âœ… fgets() - Alegerea SigurÄƒ</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Sintaxa È™i comportament fgets()</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">char *fgets(char *str, int n, FILE *stream);

/* Comportament:
 * - CiteÈ™te maxim n-1 caractere
 * - Se opreÈ™te la '\n' (care ESTE inclus Ã®n string)
 * - AdaugÄƒ automat '\0' la final
 * - ReturneazÄƒ str sau NULL (EOF/eroare)
 */

char line[256];

/* Citire linie cu linie */
while (fgets(line, sizeof(line), fp) != NULL) {
    /* EliminÄƒ newline dacÄƒ existÄƒ */
    line[strcspn(line, "\n")] = '\0';
    
    printf("Linia: [%s]\n", line);
}</code></pre>
            </div>
            <div class="two-columns">
                <div class="success-box">
                    <h4>âœ… Avantaje fgets()</h4>
                    <ul>
                        <li>Previne buffer overflow</li>
                        <li>PÄƒstreazÄƒ caracterul newline</li>
                        <li>Returnare clarÄƒ pentru EOF</li>
                    </ul>
                </div>
                <div class="warning-box">
                    <h4>âš ï¸ AtenÈ›ie</h4>
                    <ul>
                        <li>Linia poate fi trunchiatÄƒ</li>
                        <li>Newline inclus Ã®n rezultat</li>
                        <li>VerificÄƒ lungimea realÄƒ</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 15: Why gets() is Dangerous -->
        <div class="slide" data-slide="15">
            <h2>ğŸ’€ De ce gets() este Interzis</h2>
            <div class="danger-box">
                <h4>ğŸš¨ AVERTISMENT CRITIC</h4>
                <p>FuncÈ›ia <code>gets()</code> a fost ELIMINATÄ‚ din standardul C11! Nu o folosiÈ›i NICIODATÄ‚!</p>
            </div>
            <div class="two-columns">
                <div>
                    <div class="code-block">
                        <div class="code-header">
                            <span>âŒ Cod VULNERABIL</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">char buffer[10];

/* PERICOL! gets() nu È™tie 
   dimensiunea buffer-ului! */
gets(buffer);  

/* Input: "AAAAAAAAAAAAAAAAAAAAAA"
 * Rezultat: Buffer overflow!
 * Stack smashing, posibil exploit!
 */</code></pre>
                    </div>
                </div>
                <div>
                    <div class="code-block">
                        <div class="code-header">
                            <span>âœ… Cod SIGUR</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">char buffer[10];

/* SIGUR! fgets() limiteazÄƒ 
   citirea la sizeof(buffer)-1 */
fgets(buffer, sizeof(buffer), stdin);

/* Input: "AAAAAAAAAAAAAAAAAAAAAA"
 * Rezultat: buffer = "AAAAAAAAA\0"
 * Restul rÄƒmÃ¢ne Ã®n stream
 */</code></pre>
                    </div>
                </div>
            </div>
            <div class="ascii-diagram" style="font-size: 0.85rem;">
Stack Ã®nainte de overflow:          Stack dupÄƒ overflow:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Return Address     â”‚            â”‚   AAAAAAAA (corupt!) â”‚ â† Atacator controleazÄƒ!
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Saved Frame Ptr    â”‚            â”‚   AAAAAAAA (corupt!) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   buffer[10]         â”‚            â”‚   AAAAAAAAAA         â”‚ â† Overflow!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- Slide 16: fscanf() Usage -->
        <div class="slide" data-slide="16">
            <h2>ğŸ” fscanf() - Citire FormatatÄƒ</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Sintaxa È™i specificatori comuni</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">int fscanf(FILE *stream, const char *format, ...);

/* Specificatori comuni */
%d      /* Ã®ntreg zecimal */
%f, %lf /* float, double */
%s      /* string (pÃ¢nÄƒ la whitespace) */
%c      /* caracter (inclusiv whitespace) */
%[...]  /* set de caractere personalizat */
%n      /* numÄƒr de caractere citite */

/* Exemplu: citire date structurate */
int id;
char nume[50];
float nota;

/* "1234 Popescu 9.5" */
int items = fscanf(fp, "%d %49s %f", &id, nume, &nota);

if (items == 3) {
    printf("ID=%d, Nume=%s, Nota=%.1f\n", id, nume, nota);
} else {
    printf("Format invalid (citite %d cÃ¢mpuri)\n", items);
}</code></pre>
            </div>
            <div class="info-box">
                <strong>ReturneazÄƒ:</strong> NumÄƒrul de cÃ¢mpuri citite cu succes, sau <code>EOF</code> la eroare/sfÃ¢rÈ™it de fiÈ™ier.
            </div>
        </div>

        <!-- Slide 17: Writing Functions -->
        <div class="slide" data-slide="17">
            <h2>âœï¸ FuncÈ›ii de Scriere</h2>
            <table>
                <tr>
                    <th>FuncÈ›ie</th>
                    <th>Descriere</th>
                    <th>ReturneazÄƒ</th>
                    <th>Utilizare</th>
                </tr>
                <tr>
                    <td><code>fputc(c, fp)</code></td>
                    <td>Scrie un caracter</td>
                    <td>Caracterul sau EOF</td>
                    <td>Scriere caracter cu caracter</td>
                </tr>
                <tr>
                    <td><code>putc(c, fp)</code></td>
                    <td>Macro, ca fputc</td>
                    <td>Caracterul sau EOF</td>
                    <td>Echivalent rapid</td>
                </tr>
                <tr>
                    <td><code>fputs(s, fp)</code></td>
                    <td>Scrie string (fÄƒrÄƒ \n)</td>
                    <td>â‰¥0 sau EOF</td>
                    <td>Scriere string simplu</td>
                </tr>
                <tr>
                    <td><code>fprintf(fp, ...)</code></td>
                    <td>Scriere formatatÄƒ</td>
                    <td>Nr. caractere sau &lt;0</td>
                    <td>Output structurat</td>
                </tr>
            </table>
            <div class="code-block">
                <div class="code-header">
                    <span>Exemple de scriere</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">FILE *fp = fopen("output.txt", "w");

/* Scriere caracter */
fputc('A', fp);

/* Scriere string (nu adaugÄƒ newline!) */
fputs("Hello, World", fp);
fputs("\n", fp);  /* AdÄƒugÄƒm manual */

/* Scriere formatatÄƒ (cea mai flexibilÄƒ) */
fprintf(fp, "Student: %s, Nota: %.2f\n", "Ion", 9.75);

fclose(fp);</code></pre>
            </div>
        </div>

        <!-- Slide 18: fprintf() in Detail -->
        <div class="slide" data-slide="18">
            <h2>ğŸ“ fprintf() - Format Specifiers</h2>
            <table>
                <tr>
                    <th>Specificator</th>
                    <th>Tip</th>
                    <th>Exemplu</th>
                    <th>Output</th>
                </tr>
                <tr>
                    <td><code>%d</code></td>
                    <td>int</td>
                    <td><code>fprintf(fp, "%d", 42)</code></td>
                    <td>42</td>
                </tr>
                <tr>
                    <td><code>%5d</code></td>
                    <td>int (min width 5)</td>
                    <td><code>fprintf(fp, "%5d", 42)</code></td>
                    <td>&nbsp;&nbsp;&nbsp;42</td>
                </tr>
                <tr>
                    <td><code>%-5d</code></td>
                    <td>int (left align)</td>
                    <td><code>fprintf(fp, "%-5d", 42)</code></td>
                    <td>42&nbsp;&nbsp;&nbsp;</td>
                </tr>
                <tr>
                    <td><code>%05d</code></td>
                    <td>int (zero pad)</td>
                    <td><code>fprintf(fp, "%05d", 42)</code></td>
                    <td>00042</td>
                </tr>
                <tr>
                    <td><code>%.2f</code></td>
                    <td>double (2 decimals)</td>
                    <td><code>fprintf(fp, "%.2f", 3.14159)</code></td>
                    <td>3.14</td>
                </tr>
                <tr>
                    <td><code>%10.2f</code></td>
                    <td>double (width + prec)</td>
                    <td><code>fprintf(fp, "%10.2f", 3.14)</code></td>
                    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.14</td>
                </tr>
                <tr>
                    <td><code>%s</code></td>
                    <td>string</td>
                    <td><code>fprintf(fp, "%s", "text")</code></td>
                    <td>text</td>
                </tr>
                <tr>
                    <td><code>%10s</code></td>
                    <td>string (min width)</td>
                    <td><code>fprintf(fp, "%10s", "text")</code></td>
                    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text</td>
                </tr>
            </table>
        </div>

        <!-- Slide 19: CSV Parsing Basics -->
        <div class="slide" data-slide="19">
            <h2>ğŸ“Š Parsarea FiÈ™ierelor CSV</h2>
            <div class="info-box">
                <strong>CSV (Comma-Separated Values)</strong> - format simplu pentru date tabulare, unde cÃ¢mpurile sunt separate prin virgulÄƒ.
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Parser CSV simplu</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void parse_csv_line(char *line) {
    char *token = strtok(line, ",");
    int field = 0;
    
    while (token != NULL) {
        /* EliminÄƒ spaÈ›ii de la Ã®nceput/final */
        while (*token == ' ') token++;
        
        printf("CÃ¢mp %d: [%s]\n", ++field, token);
        token = strtok(NULL, ",");
    }
}

int main(void) {
    FILE *fp = fopen("data.csv", "r");
    char line[1024];
    
    while (fgets(line, sizeof(line), fp)) {
        line[strcspn(line, "\n")] = '\0';
        parse_csv_line(line);
        printf("---\n");
    }
    
    fclose(fp);
    return 0;
}</code></pre>
            </div>
        </div>

        <!-- Slide 20: Advanced CSV Parsing -->
        <div class="slide" data-slide="20">
            <h2>ğŸ”¬ CSV Avansat - Ghilimele È™i Caractere Speciale</h2>
            <div class="warning-box">
                <strong>âš ï¸ ProblemÄƒ:</strong> Ce se Ã®ntÃ¢mplÄƒ cÃ¢nd un cÃ¢mp conÈ›ine virgulÄƒ sau newline?
                <br><br>
                <code>"Popescu, Ion",25,"BucureÈ™ti, Sector 1"</code>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Parser CSV cu suport pentru ghilimele</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef enum { NORMAL, IN_QUOTES } ParseState;

char *get_csv_field(char **line) {
    static char field[256];
    char *p = *line, *out = field;
    ParseState state = NORMAL;
    
    while (*p) {
        if (state == NORMAL) {
            if (*p == '"') {
                state = IN_QUOTES;
            } else if (*p == ',') {
                p++;  /* Sare peste virgulÄƒ */
                break;
            } else {
                *out++ = *p;
            }
        } else {  /* IN_QUOTES */
            if (*p == '"') {
                if (*(p+1) == '"') {
                    *out++ = '"';  /* "" devine " */
                    p++;
                } else {
                    state = NORMAL;
                }
            } else {
                *out++ = *p;
            }
        }
        p++;
    }
    *out = '\0';
    *line = p;
    return field;
}</code></pre>
            </div>
        </div>

        <!-- Slide 21: File Position Functions -->
        <div class="slide" data-slide="21">
            <h2>ğŸ“ PoziÈ›ionare Ã®n FiÈ™ier: fseek() È™i ftell()</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ii de poziÈ›ionare</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* ObÈ›ine poziÈ›ia curentÄƒ */
long ftell(FILE *stream);

/* SeteazÄƒ poziÈ›ia */
int fseek(FILE *stream, long offset, int whence);

/* whence poate fi: */
SEEK_SET  /* FaÈ›Äƒ de Ã®nceputul fiÈ™ierului */
SEEK_CUR  /* FaÈ›Äƒ de poziÈ›ia curentÄƒ */
SEEK_END  /* FaÈ›Äƒ de sfÃ¢rÈ™itul fiÈ™ierului */

/* Revine la Ã®nceputul fiÈ™ierului */
void rewind(FILE *stream);  /* echivalent fseek(fp, 0, SEEK_SET) */</code></pre>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Exemplu: Determinarea dimensiunii fiÈ™ierului</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">long get_file_size(FILE *fp) {
    long current = ftell(fp);     /* SalveazÄƒ poziÈ›ia curentÄƒ */
    fseek(fp, 0, SEEK_END);       /* Mergi la sfÃ¢rÈ™it */
    long size = ftell(fp);        /* CiteÈ™te poziÈ›ia = dimensiune */
    fseek(fp, current, SEEK_SET); /* RestaureazÄƒ poziÈ›ia */
    return size;
}</code></pre>
            </div>
        </div>

        <!-- Slide 22: Error Detection -->
        <div class="slide" data-slide="22">
            <h2>ğŸ” Detectarea Erorilor: feof() È™i ferror()</h2>
            <div class="two-columns">
                <div>
                    <h3>feof(FILE *fp)</h3>
                    <p>VerificÄƒ dacÄƒ s-a atins sfÃ¢rÈ™itul fiÈ™ierului.</p>
                    <div class="warning-box">
                        <strong>âš ï¸ CapcanÄƒ comunÄƒ:</strong>
                        <code>feof()</code> returneazÄƒ true <em>dupÄƒ</em> o citire eÈ™uatÄƒ, nu Ã®nainte!
                    </div>
                    <div class="code-block">
                        <div class="code-header">
                            <span>âŒ GreÈ™it</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">while (!feof(fp)) {  /* NU! */
    fgets(line, 256, fp);
    process(line);
}</code></pre>
                    </div>
                </div>
                <div>
                    <h3>ferror(FILE *fp)</h3>
                    <p>VerificÄƒ dacÄƒ a apÄƒrut o eroare la ultima operaÈ›ie.</p>
                    <div class="code-block">
                        <div class="code-header">
                            <span>âœ… Corect</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">while (fgets(line, 256, fp)) {
    process(line);
}

if (ferror(fp)) {
    perror("Eroare citire");
}
/* feof(fp) e true aici */</code></pre>
                    </div>
                    <div class="info-box">
                        <code>clearerr(fp)</code> reseteazÄƒ indicatorii EOF È™i eroare.
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 23: Practical Example - Student Database -->
        <div class="slide" data-slide="23">
            <h2>ğŸ’¼ Exemplu Practic: BazÄƒ de Date StudenÈ›i</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Citire date studenÈ›i din CSV</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef struct {
    int id;
    char nume[50];
    char prenume[50];
    int an;
    int grupa;
    int note[10];
} Student;

int citeste_studenti(const char *filename, Student studenti[], int max) {
    FILE *fp = fopen(filename, "r");
    if (!fp) return -1;
    
    char line[512];
    int count = 0;
    
    while (count < max && fgets(line, sizeof(line), fp)) {
        Student *s = &studenti[count];
        
        int items = sscanf(line, "%d %49s %49s %d %d %d %d %d %d %d %d %d %d %d %d",
            &s->id, s->nume, s->prenume, &s->an, &s->grupa,
            &s->note[0], &s->note[1], &s->note[2], &s->note[3], &s->note[4],
            &s->note[5], &s->note[6], &s->note[7], &s->note[8], &s->note[9]);
        
        if (items >= 5) count++;
    }
    
    fclose(fp);
    return count;
}</code></pre>
            </div>
        </div>

        <!-- Slide 24: Practical Example - Report Generation -->
        <div class="slide" data-slide="24">
            <h2>ğŸ“‹ Exemplu Practic: Generare Raport</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Generarea unui raport formatat</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void genereaza_raport(const char *filename, Student studenti[], int n) {
    FILE *fp = fopen(filename, "w");
    if (!fp) return;
    
    /* Header */
    fprintf(fp, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    fprintf(fp, "â•‘              RAPORT NOTE STUDENÈšI                          â•‘\n");
    fprintf(fp, "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    fprintf(fp, "â•‘ %-8s â”‚ %-20s â”‚ %6s â”‚ %8s â•‘\n", 
            "ID", "Nume", "Grupa", "Medie");
    fprintf(fp, "â• â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•£\n");
    
    double suma_totala = 0;
    for (int i = 0; i < n; i++) {
        double medie = calculeaza_medie(&studenti[i]);
        suma_totala += medie;
        
        fprintf(fp, "â•‘ %-8d â”‚ %-20s â”‚ %6d â”‚ %8.2f â•‘\n",
                studenti[i].id, studenti[i].nume,
                studenti[i].grupa, medie);
    }
    
    fprintf(fp, "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    fprintf(fp, "â•‘ Media generalÄƒ: %8.2f                                   â•‘\n",
            suma_totala / n);
    fprintf(fp, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    fclose(fp);
}</code></pre>
            </div>
        </div>

        <!-- Slide 25: Common Mistakes #1 -->
        <div class="slide" data-slide="25">
            <h2>âŒ GreÈ™eli Frecvente (Partea 1)</h2>
            <div class="do-dont">
                <div class="dont-column">
                    <h4>âŒ GREÈ˜IT</h4>
                    <div class="code-block">
                        <pre><code class="language-c">/* 1. Nu verifici returnul fopen */
FILE *fp = fopen("file.txt", "r");
fscanf(fp, "%d", &x);  /* CRASH! */

/* 2. UiÈ›i sÄƒ Ã®nchizi fiÈ™ierul */
void process() {
    FILE *fp = fopen("data.txt", "r");
    /* ... */
    return;  /* Memory leak! */
}

/* 3. FoloseÈ™ti gets() */
gets(buffer);  /* Buffer overflow! */

/* 4. Verifici feof() Ã®nainte de citire */
while (!feof(fp)) {
    fgets(line, 256, fp);
    /* ProceseazÄƒ linie GOALÄ‚! */
}</code></pre>
                    </div>
                </div>
                <div class="do-column">
                    <h4>âœ… CORECT</h4>
                    <div class="code-block">
                        <pre><code class="language-c">/* 1. VerificÄƒ Ã®ntotdeauna */
FILE *fp = fopen("file.txt", "r");
if (fp == NULL) {
    perror("Eroare"); return;
}

/* 2. Ãnchide MEREU fiÈ™ierul */
void process() {
    FILE *fp = fopen("data.txt", "r");
    /* ... */
    fclose(fp);  /* OK! */
    return;
}

/* 3. FoloseÈ™te fgets() */
fgets(buffer, sizeof(buffer), fp);

/* 4. VerificÄƒ returnul funcÈ›iei */
while (fgets(line, 256, fp)) {
    /* ProceseazÄƒ linie VALIDÄ‚ */
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 26: Common Mistakes #2 -->
        <div class="slide" data-slide="26">
            <h2>âŒ GreÈ™eli Frecvente (Partea 2)</h2>
            <div class="do-dont">
                <div class="dont-column">
                    <h4>âŒ GREÈ˜IT</h4>
                    <div class="code-block">
                        <pre><code class="language-c">/* 5. scanf("%s") fÄƒrÄƒ limitÄƒ */
scanf("%s", buffer);  /* Overflow! */

/* 6. IgnorÄƒ newline-ul din fgets */
fgets(name, 50, fp);
/* name = "Ion\n" - cu newline! */
if (strcmp(name, "Ion") == 0)
    /* Nu se potriveÈ™te! */

/* 7. Deschide Ã®n modul greÈ™it */
FILE *fp = fopen("data.txt", "w");
/* Tot conÈ›inutul a fost È˜TERS! */
fgets(line, 256, fp);  /* ??? */

/* 8. Nu verifici nr. cÃ¢mpuri citite */
fscanf(fp, "%d %s", &id, name);
/* Ce dacÄƒ fiÈ™ierul e gol? */</code></pre>
                    </div>
                </div>
                <div class="do-column">
                    <h4>âœ… CORECT</h4>
                    <div class="code-block">
                        <pre><code class="language-c">/* 5. LimiteazÄƒ lungimea */
scanf("%49s", buffer);  /* max 49 chars */

/* 6. EliminÄƒ newline-ul */
fgets(name, 50, fp);
name[strcspn(name, "\n")] = '\0';
if (strcmp(name, "Ion") == 0)
    /* FuncÈ›ioneazÄƒ! */

/* 7. VerificÄƒ modul */
FILE *fp = fopen("data.txt", "r");
/* Citire sigurÄƒ */
fgets(line, 256, fp);  /* OK */

/* 8. VerificÄƒ returnul */
if (fscanf(fp, "%d %s", &id, name) == 2) {
    /* Date valide */
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 27: Memory Model -->
        <div class="slide" data-slide="27">
            <h2>ğŸ§  Modelul de Memorie pentru I/O</h2>
            <div class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FLUXUL DATELOR ÃN OPERAÈšII I/O                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   SCRIERE (fprintf, fputs, fputc)                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚   â”‚ Variab. â”‚â”€â”€â”€â–ºâ”‚ User Space  â”‚â”€â”€â”€â–ºâ”‚  Kernel   â”‚â”€â”€â”€â–ºâ”‚   Disc/SSD  â”‚         â”‚
â”‚   â”‚ Program â”‚    â”‚   Buffer    â”‚    â”‚  Buffer   â”‚    â”‚   Hardware  â”‚         â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                        â”‚                  â”‚                                  â”‚
â”‚                   fflush(fp)         sync/fsync                              â”‚
â”‚                                                                              â”‚
â”‚   CITIRE (fscanf, fgets, fgetc)                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚   â”‚ Variab. â”‚â—„â”€â”€â”€â”‚ User Space  â”‚â—„â”€â”€â”€â”‚  Kernel   â”‚â—„â”€â”€â”€â”‚   Disc/SSD  â”‚         â”‚
â”‚   â”‚ Program â”‚    â”‚   Buffer    â”‚    â”‚  Buffer   â”‚    â”‚   Hardware  â”‚         â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                              â”‚
â”‚   Dimensiuni tipice:                                                         â”‚
â”‚   â€¢ User buffer (stdio): 4-8 KB per stream                                   â”‚
â”‚   â€¢ Kernel buffer: variabil, gestionat de OS                                 â”‚
â”‚   â€¢ Bloc disc: 512B - 4KB                                                    â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- Slide 28: Debugging with GDB -->
        <div class="slide" data-slide="28">
            <h2>ğŸ”§ Debugging I/O cu GDB</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Comenzi GDB utile pentru debugging I/O</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Compilare cu simboluri de debug
gcc -g -Wall -Wextra -o program program.c

# Rulare Ã®n GDB
gdb ./program

# Comenzi Ã®n GDB:
(gdb) break main              # Breakpoint la main
(gdb) break fopen             # Breakpoint la fopen
(gdb) run                     # PorneÈ™te execuÈ›ia
(gdb) next                    # ExecutÄƒ linia curentÄƒ
(gdb) print fp                # AfiÈ™eazÄƒ valoarea FILE*
(gdb) print *fp               # AfiÈ™eazÄƒ conÈ›inutul structurii
(gdb) print buffer            # AfiÈ™eazÄƒ conÈ›inutul buffer-ului
(gdb) x/s buffer              # AfiÈ™eazÄƒ ca string
(gdb) watch line              # OpreÈ™te cÃ¢nd line se modificÄƒ
(gdb) continue                # ContinuÄƒ pÃ¢nÄƒ la urmÄƒtorul breakpoint</code></pre>
            </div>
            <div class="info-box">
                <strong>Sfat:</strong> FoloseÈ™te <code>strace ./program</code> pentru a vedea toate apelurile sistem (open, read, write, close).
            </div>
        </div>

        <!-- Slide 29: Valgrind for File Operations -->
        <div class="slide" data-slide="29">
            <h2>ğŸ” Verificare cu Valgrind</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Detectarea problemelor cu Valgrind</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Verificare memory leaks È™i file descriptors
valgrind --leak-check=full \
         --show-leak-kinds=all \
         --track-fds=yes \
         ./program

# Output tipic pentru fiÈ™ier neÃ®nchis:
==12345== FILE DESCRIPTORS: 4 open at exit.
==12345== Open file descriptor 3: /path/to/file.txt
==12345==    at 0x4C2F1E: fopen (vg_replace_strmem.c:1234)
==12345==    by 0x401234: main (program.c:15)</code></pre>
            </div>
            <div class="warning-box">
                <strong>âš ï¸ Indicatori de probleme:</strong>
                <ul>
                    <li><code>definitely lost</code> - memorie neeliberatÄƒ (fclose() lipsÄƒ)</li>
                    <li><code>Invalid read/write</code> - buffer overflow</li>
                    <li><code>Uninitialised value</code> - variabilÄƒ neiniÈ›ializatÄƒ</li>
                    <li><code>FILE DESCRIPTORS: N open at exit</code> - fiÈ™iere neÃ®nchise</li>
                </ul>
            </div>
        </div>

        <!-- Slide 30: Best Practices -->
        <div class="slide" data-slide="30">
            <h2>âœ¨ Bune Practici</h2>
            <div class="card-grid">
                <div class="card">
                    <h4>1. VerificÄƒ ÃNTOTDEAUNA</h4>
                    <p>VerificÄƒ returnul fiecÄƒrei funcÈ›ii I/O. NULL de la fopen(), EOF de la fscanf().</p>
                </div>
                <div class="card">
                    <h4>2. Ãnchide fiÈ™ierele</h4>
                    <p>FoloseÈ™te fclose() pentru FIECARE fopen(). ConsiderÄƒ pattern-ul RAII cu goto cleanup.</p>
                </div>
                <div class="card">
                    <h4>3. FoloseÈ™te fgets()</h4>
                    <p>Pentru citire linii, fgets() e mai sigur decÃ¢t scanf("%s") sau gets().</p>
                </div>
                <div class="card">
                    <h4>4. LimiteazÄƒ buffer-ele</h4>
                    <p>SpecificÄƒ dimensiunea maximÄƒ: scanf("%99s"), fgets(buf, sizeof(buf), fp).</p>
                </div>
                <div class="card">
                    <h4>5. TesteazÄƒ edge cases</h4>
                    <p>FiÈ™ier gol, linie foarte lungÄƒ, caractere speciale, format invalid.</p>
                </div>
                <div class="card">
                    <h4>6. DocumenteazÄƒ formatele</h4>
                    <p>SpecificÄƒ formatul aÈ™teptat Ã®n comentarii. ValideazÄƒ la citire.</p>
                </div>
            </div>
        </div>

        <!-- Slide 31: RAII Pattern in C -->
        <div class="slide" data-slide="31">
            <h2>ğŸ—ï¸ Pattern-ul Cleanup cu goto</h2>
            <div class="code-block">
                <div class="code-header">
                    <span>Gestionarea resurselor cu goto cleanup</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">int process_files(const char *input, const char *output) {
    FILE *fin = NULL, *fout = NULL;
    char *buffer = NULL;
    int result = -1;  /* Presupunem eroare */
    
    /* AlocÄƒ resurse */
    fin = fopen(input, "r");
    if (!fin) goto cleanup;
    
    fout = fopen(output, "w");
    if (!fout) goto cleanup;
    
    buffer = malloc(4096);
    if (!buffer) goto cleanup;
    
    /* Procesare */
    while (fgets(buffer, 4096, fin)) {
        if (fputs(buffer, fout) == EOF) goto cleanup;
    }
    
    result = 0;  /* Succes */
    
cleanup:
    /* ElibereazÄƒ TOATE resursele Ã®n ordine inversÄƒ */
    free(buffer);
    if (fout) fclose(fout);
    if (fin) fclose(fin);
    
    return result;
}</code></pre>
            </div>
            <div class="success-box">
                <strong>âœ… Avantaje:</strong> Un singur punct de ieÈ™ire pentru cleanup, cod clar, imposibil sÄƒ uiÈ›i sÄƒ eliberezi resurse.
            </div>
        </div>

        <!-- Slide 32: Performance Considerations -->
        <div class="slide" data-slide="32">
            <h2>âš¡ ConsideraÈ›ii de PerformanÈ›Äƒ</h2>
            <table>
                <tr>
                    <th>OperaÈ›ie</th>
                    <th>Timp Relativ</th>
                    <th>Recomandare</th>
                </tr>
                <tr>
                    <td>Citire caracter cu caracter</td>
                    <td>ğŸ”´ Lent</td>
                    <td>FoloseÈ™te fgets() pentru linii</td>
                </tr>
                <tr>
                    <td>Citire Ã®n buffer mare</td>
                    <td>ğŸŸ¢ Rapid</td>
                    <td>Dimensiune buffer = multiplu de 4KB</td>
                </tr>
                <tr>
                    <td>fprintf() repetat</td>
                    <td>ğŸŸ¡ Mediu</td>
                    <td>ConstruieÈ™te string, apoi scrie odatÄƒ</td>
                </tr>
                <tr>
                    <td>fflush() frecvent</td>
                    <td>ğŸ”´ Lent</td>
                    <td>LasÄƒ buffering-ul automat sÄƒ funcÈ›ioneze</td>
                </tr>
                <tr>
                    <td>fseek() + citire micÄƒ</td>
                    <td>ğŸ”´ Lent</td>
                    <td>CiteÈ™te secvenÈ›ial cÃ¢nd e posibil</td>
                </tr>
            </table>
            <div class="code-block">
                <div class="code-header">
                    <span>Optimizare: Buffer mare personalizat</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Pentru fiÈ™iere foarte mari */
#define BUFFER_SIZE (64 * 1024)  /* 64 KB */

FILE *fp = fopen("big_file.csv", "r");
char *big_buffer = malloc(BUFFER_SIZE);
setvbuf(fp, big_buffer, _IOFBF, BUFFER_SIZE);
/* Citire de ~2-3x mai rapidÄƒ pentru fiÈ™iere mari */</code></pre>
            </div>
        </div>

        <!-- Slide 33: Laboratory Preview -->
        <div class="slide" data-slide="33">
            <h2>ğŸ”¬ Previzualizare Laborator</h2>
            <div class="two-columns">
                <div class="card">
                    <h4>ğŸ“ ExerciÈ›iul 1: Analizator de Note</h4>
                    <p>Citirea È™i procesarea unui fiÈ™ier CSV cu date studenÈ›eÈ™ti:</p>
                    <ul>
                        <li>8 TODO markers</li>
                        <li>Parsare CSV cu validare</li>
                        <li>Calcul statistici (medie, min, max)</li>
                        <li>Generare raport formatat</li>
                        <li>Sortare dupÄƒ medie</li>
                    </ul>
                    <p><strong>Timp estimat:</strong> 45-60 minute</p>
                </div>
                <div class="card">
                    <h4>âš™ï¸ ExerciÈ›iul 2: Parser ConfiguraÈ›ie</h4>
                    <p>Implementarea unui parser pentru fiÈ™iere INI:</p>
                    <ul>
                        <li>12 TODO markers</li>
                        <li>Suport secÈ›iuni [Section]</li>
                        <li>Perechi cheie=valoare</li>
                        <li>Ignorare comentarii (#, ;)</li>
                        <li>Validare tipuri de date</li>
                    </ul>
                    <p><strong>Timp estimat:</strong> 60-75 minute</p>
                </div>
            </div>
            <div class="info-box" style="margin-top: 30px;">
                <strong>ğŸ“ FiÈ™iere disponibile:</strong>
                <code>src/exercise1.c</code>, <code>src/exercise2.c</code>, <code>data/studgrades.csv</code>, <code>data/config_sample.ini</code>
            </div>
        </div>

        <!-- Slide 34: Key Takeaways -->
        <div class="slide" data-slide="34">
            <h2>ğŸ“Œ Rezumat - Concepte Cheie</h2>
            <div class="summary-grid">
                <div class="summary-item">
                    <div class="icon">ğŸ“‚</div>
                    <h4>fopen/fclose</h4>
                    <p>Deschide cu verificare, Ã®nchide MEREU</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸ”</div>
                    <h4>Moduri</h4>
                    <p>r, w, a, r+, w+, a+ - alege corect!</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸ“–</div>
                    <h4>fgets()</h4>
                    <p>Citire sigurÄƒ, cu limitÄƒ de dimensiune</p>
                </div>
                <div class="summary-item">
                    <div class="icon">âœï¸</div>
                    <h4>fprintf()</h4>
                    <p>Scriere formatatÄƒ, flexibilÄƒ</p>
                </div>
                <div class="summary-item">
                    <div class="icon">ğŸš¿</div>
                    <h4>Buffering</h4>
                    <p>Full, Line, None - optimizare I/O</p>
                </div>
                <div class="summary-item">
                    <div class="icon">âš ï¸</div>
                    <h4>Erori</h4>
                    <p>VerificÄƒ returnul, foloseÈ™te perror()</p>
                </div>
            </div>
        </div>

        <!-- Slide 35: Resources -->
        <div class="slide" data-slide="35">
            <h2>ğŸ“š Resurse pentru Studiu</h2>
            <div class="three-columns">
                <div class="column">
                    <h3 style="color: var(--accent-blue);">ğŸ“– CÄƒrÈ›i</h3>
                    <ul>
                        <li>K&R - "The C Programming Language" Cap. 7</li>
                        <li>Stevens - "Advanced Programming in the UNIX Environment" Cap. 5</li>
                        <li>King - "C Programming: A Modern Approach" Cap. 22</li>
                    </ul>
                </div>
                <div class="column">
                    <h3 style="color: var(--accent-green);">ğŸŒ Online</h3>
                    <ul>
                        <li><a href="https://en.cppreference.com/w/c/io" style="color: var(--accent-blue);">cppreference.com</a></li>
                        <li><a href="https://www.gnu.org/software/libc/manual/" style="color: var(--accent-blue);">GNU C Library Manual</a></li>
                        <li><a href="https://beej.us/guide/bgc/" style="color: var(--accent-blue);">Beej's Guide to C</a></li>
                    </ul>
                </div>
                <div class="column">
                    <h3 style="color: var(--accent-purple);">ğŸ“„ Standarde</h3>
                    <ul>
                        <li>ISO/IEC 9899:2011 (C11)</li>
                        <li>POSIX.1-2017</li>
                        <li>RFC 4180 (CSV)</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 36: Questions -->
        <div class="slide title-slide" data-slide="36">
            <h1>â“ ÃntrebÄƒri?</h1>
            <p class="subtitle">VÄƒ mulÈ›umesc pentru atenÈ›ie!</p>
            <div style="margin-top: 50px;">
                <h3 style="color: var(--accent-green);">ğŸ”® SÄƒptÄƒmÃ¢na viitoare:</h3>
                <p style="font-size: 1.4rem;">FiÈ™iere Binare - fread(), fwrite(), serialization</p>
            </div>
            <p style="margin-top: 50px; font-size: 1rem; color: var(--text-secondary);">
                ATP | Academia de Studii Economice BucureÈ™ti
            </p>
        </div>

    </div>

    <!-- Navigation -->
    <div class="slide-counter">
        <span id="currentSlide">1</span> / <span id="totalSlides">36</span>
    </div>
    
    <div class="nav-container">
        <button class="nav-btn" onclick="prevSlide()">â—€ Ãnapoi</button>
        <button class="nav-btn" onclick="nextSlide()">Ãnainte â–¶</button>
    </div>

    <script>
        hljs.highlightAll();

        let currentSlide = 1;
        const totalSlides = document.querySelectorAll('.slide').length;
        
        document.getElementById('totalSlides').textContent = totalSlides;

        function showSlide(n) {
            const slides = document.querySelectorAll('.slide');
            
            if (n > totalSlides) currentSlide = 1;
            if (n < 1) currentSlide = totalSlides;
            
            slides.forEach(slide => {
                slide.classList.remove('active');
            });
            
            slides[currentSlide - 1].classList.add('active');
            document.getElementById('currentSlide').textContent = currentSlide;
            
            // Update progress bar
            const progress = (currentSlide / totalSlides) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        function nextSlide() {
            currentSlide++;
            showSlide(currentSlide);
        }

        function prevSlide() {
            currentSlide--;
            showSlide(currentSlide);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                case 'PageDown':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'ArrowLeft':
                case 'PageUp':
                    e.preventDefault();
                    prevSlide();
                    break;
                case 'Home':
                    e.preventDefault();
                    currentSlide = 1;
                    showSlide(currentSlide);
                    break;
                case 'End':
                    e.preventDefault();
                    currentSlide = totalSlides;
                    showSlide(currentSlide);
                    break;
            }
        });

        // Initialize
        showSlide(currentSlide);
    </script>
</body>
</html>
