<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SÄƒptÄƒmÃ¢na 04: Liste ÃnlÄƒnÈ›uite | ATP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <style>
        /* =================================================================
           TEMA PRINCIPALÄ‚ - GitHub Dark Style
           ================================================================= */
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --border-color: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        /* =================================================================
           PROGRESS BAR
           ================================================================= */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            z-index: 1000;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            transition: width 0.3s ease;
        }

        /* =================================================================
           SLIDE CONTAINER
           ================================================================= */
        .slides-container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }

        /* =================================================================
           TITLURI
           ================================================================= */
        h1 {
            font-size: 2.8rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--accent-blue);
            padding-bottom: 0.5rem;
        }

        h2 {
            font-size: 2rem;
            font-weight: 600;
            color: var(--accent-blue);
            margin-bottom: 1rem;
        }

        h3 {
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--accent-green);
            margin-bottom: 0.8rem;
        }

        /* =================================================================
           TEXT È˜I LISTE
           ================================================================= */
        p {
            font-size: 1.2rem;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        li {
            font-size: 1.15rem;
            margin-bottom: 0.6rem;
            color: var(--text-primary);
        }

        li::marker {
            color: var(--accent-blue);
        }

        /* =================================================================
           BLOCURI DE COD
           ================================================================= */
        .code-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 1rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .lang-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .code-block pre {
            margin: 0;
            padding: 1rem;
            overflow-x: auto;
        }

        .code-block code {
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        /* =================================================================
           DIAGRAME ASCII
           ================================================================= */
        .ascii-diagram {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre;
            overflow-x: auto;
            color: var(--accent-green);
        }

        /* =================================================================
           CASETE SPECIALE
           ================================================================= */
        .info-box {
            background: rgba(88, 166, 255, 0.1);
            border-left: 4px solid var(--accent-blue);
            padding: 1rem 1.5rem;
            border-radius: 0 8px 8px 0;
            margin: 1rem 0;
        }

        .warning-box {
            background: rgba(210, 153, 34, 0.1);
            border-left: 4px solid var(--accent-yellow);
            padding: 1rem 1.5rem;
            border-radius: 0 8px 8px 0;
            margin: 1rem 0;
        }

        .danger-box {
            background: rgba(248, 81, 73, 0.1);
            border-left: 4px solid var(--accent-red);
            padding: 1rem 1.5rem;
            border-radius: 0 8px 8px 0;
            margin: 1rem 0;
        }

        .success-box {
            background: rgba(63, 185, 80, 0.1);
            border-left: 4px solid var(--accent-green);
            padding: 1rem 1.5rem;
            border-radius: 0 8px 8px 0;
            margin: 1rem 0;
        }

        /* =================================================================
           TABELE
           ================================================================= */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            padding: 0.8rem 1rem;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* =================================================================
           GRID LAYOUT
           ================================================================= */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 1rem 0;
        }

        .three-columns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1.5rem;
            margin: 1rem 0;
        }

        .column {
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* =================================================================
           CARD BOXES
           ================================================================= */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 0.5rem 0;
        }

        .card-title {
            color: var(--accent-blue);
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        /* =================================================================
           QUOTE BOX
           ================================================================= */
        .quote-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-purple);
            padding: 1.5rem;
            margin: 1rem 0;
            font-style: italic;
            border-radius: 0 8px 8px 0;
        }

        .quote-author {
            text-align: right;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            font-style: normal;
        }

        /* =================================================================
           HIGHLIGHT TEXT
           ================================================================= */
        .highlight {
            color: var(--accent-yellow);
            font-weight: 600;
        }

        .keyword {
            color: var(--accent-purple);
            font-family: 'Fira Code', monospace;
            background: var(--bg-tertiary);
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
        }

        /* =================================================================
           TITLE SLIDE
           ================================================================= */
        .title-slide {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .title-slide h1 {
            font-size: 3.5rem;
            border: none;
            margin-bottom: 0.5rem;
        }

        .title-slide .subtitle {
            font-size: 1.8rem;
            color: var(--accent-blue);
            margin-bottom: 2rem;
        }

        .title-slide .meta {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* =================================================================
           NAVIGATION
           ================================================================= */
        .navigation {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.6rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        /* =================================================================
           SLIDE COUNTER
           ================================================================= */
        .slide-counter {
            position: fixed;
            bottom: 25px;
            left: 30px;
            color: var(--text-secondary);
            font-size: 0.9rem;
            z-index: 100;
        }

        /* =================================================================
           EMOJI ICONS
           ================================================================= */
        .emoji-large {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        /* =================================================================
           SUMMARY BOXES
           ================================================================= */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .summary-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }

        .summary-box .icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .summary-box .label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* =================================================================
           RESPONSIVE
           ================================================================= */
        @media (max-width: 1200px) {
            .slide {
                padding: 40px 50px;
            }
            h1 { font-size: 2.2rem; }
            h2 { font-size: 1.6rem; }
        }

        @media (max-width: 768px) {
            .two-columns, .three-columns {
                grid-template-columns: 1fr;
            }
            .summary-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <!-- Slides Container -->
    <div class="slides-container" id="slidesContainer">

        <!-- ============================================================
             SLIDE 1: TITLU
             ============================================================ -->
        <div class="slide title-slide active">
            <div class="emoji-large">ğŸ”—</div>
            <h1>Liste ÃnlÄƒnÈ›uite</h1>
            <p class="subtitle">Linked Lists Ã®n C</p>
            <p class="meta">
                <strong>SÄƒptÄƒmÃ¢na 04</strong> | Algoritmi È™i Tehnici de Programare<br>
                Academia de Studii Economice, BucureÈ™ti
            </p>
        </div>

        <!-- ============================================================
             SLIDE 2: OBIECTIVE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ¯ Obiective de ÃnvÄƒÈ›are</h1>
            <p>La finalul acestei prezentÄƒri, veÈ›i fi capabili sÄƒ:</p>
            <ol>
                <li><strong>RecunoaÈ™teÈ›i</strong> È™i descrieÈ›i structura unui nod È™i a unei liste Ã®nlÄƒnÈ›uite</li>
                <li><strong>ÃnÈ›elegeÈ›i</strong> diferenÈ›ele dintre alocarea staticÄƒ È™i dinamicÄƒ a memoriei</li>
                <li><strong>AplicaÈ›i</strong> operaÈ›iile fundamentale: inserare, È™tergere, cÄƒutare</li>
                <li><strong>AnalizaÈ›i</strong> complexitatea temporalÄƒ È™i spaÈ›ialÄƒ a operaÈ›iilor</li>
                <li><strong>EvaluaÈ›i</strong> cÃ¢nd sÄƒ folosiÈ›i linked list vs. array</li>
                <li><strong>CreaÈ›i</strong> implementÄƒri complete cu gestiune corectÄƒ a memoriei</li>
            </ol>
            <div class="info-box">
                <strong>ğŸ“Œ NotÄƒ:</strong> Listele Ã®nlÄƒnÈ›uite sunt fundamentul pentru stive, cozi, arbori È™i grafuri!
            </div>
        </div>

        <!-- ============================================================
             SLIDE 3: CONTEXT ISTORIC
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ“œ Context Istoric</h1>
            <div class="two-columns">
                <div>
                    <h3>Timeline</h3>
                    <ul>
                        <li><strong>1955-1956:</strong> IPL (Information Processing Language) - prima implementare</li>
                        <li><strong>1958:</strong> LISP (List Processing) - John McCarthy</li>
                        <li><strong>1960s:</strong> Adoptare Ã®n sisteme de operare</li>
                        <li><strong>Prezent:</strong> Fundament al structurilor de date moderne</li>
                    </ul>
                </div>
                <div>
                    <h3>AplicaÈ›ii Istorice</h3>
                    <ul>
                        <li>Logic Theorist - primul program AI</li>
                        <li>Compilatoare È™i interpretoare</li>
                        <li>Gestiunea memoriei Ã®n SO</li>
                        <li>Baze de date timpurii</li>
                    </ul>
                </div>
            </div>
            <div class="info-box">
                IPL a fost dezvoltat pentru a crea inteligenÈ›Äƒ artificialÄƒ - linked lists au fost inventate pentru a reprezenta cunoaÈ™terea!
            </div>
        </div>

        <!-- ============================================================
             SLIDE 4: FIGURÄ‚ CHEIE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ‘¨â€ğŸ”¬ FigurÄƒ Cheie: Allen Newell</h1>
            <div class="two-columns">
                <div>
                    <h3>Biografie (1927-1992)</h3>
                    <ul>
                        <li>Pionier al inteligenÈ›ei artificiale</li>
                        <li>Co-creator al IPL È™i linked lists</li>
                        <li>Premiul Turing 1975</li>
                        <li>Profesor la Carnegie Mellon</li>
                    </ul>
                    <h3>ContribuÈ›ii</h3>
                    <ul>
                        <li>Logic Theorist (1956)</li>
                        <li>General Problem Solver</li>
                        <li>Teoria unitarÄƒ a cogniÈ›iei</li>
                    </ul>
                </div>
                <div>
                    <div class="quote-box">
                        â€Computerul este remarcabil nu pentru ceea ce poate face, ci pentru ceea ce ne permite sÄƒ gÃ¢ndim."
                        <p class="quote-author">â€” Allen Newell</p>
                    </div>
                    <div class="success-box">
                        <strong>Impact:</strong> Conceptele dezvoltate de Newell stau la baza programÄƒrii moderne È™i a inteligenÈ›ei artificiale.
                    </div>
                </div>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 5: DE CE LINKED LISTS?
             ============================================================ -->
        <div class="slide">
            <h1>â“ De Ce Avem Nevoie de Linked Lists?</h1>
            <div class="two-columns">
                <div>
                    <h3>LimitÄƒrile Array-urilor</h3>
                    <ul>
                        <li>Dimensiune fixÄƒ la declarare</li>
                        <li>Inserarea/È™tergerea necesitÄƒ mutarea elementelor</li>
                        <li>Redimensionarea este costisitoare</li>
                        <li>Memoria trebuie sÄƒ fie contiguÄƒ</li>
                    </ul>
                </div>
                <div>
                    <h3>Avantajele Linked Lists</h3>
                    <ul>
                        <li>Dimensiune dinamicÄƒ</li>
                        <li>Inserare/È™tergere Ã®n O(1)*</li>
                        <li>Nu necesitÄƒ memorie contiguÄƒ</li>
                        <li>Utilizare eficientÄƒ a memoriei</li>
                    </ul>
                </div>
            </div>
            <div class="ascii-diagram">
ARRAY (inserare la poziÈ›ia 2):         LINKED LIST (inserare):
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”                  â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚ E â”‚ â†’ mutÄƒ C,D,E     â”‚ A â”œâ”€â”€â–ºâ”‚ X â”œâ”€â”€â–ºâ”‚ B â”‚ â†’ doar schimbÄƒ pointeri
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜                  â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜
    O(n) operaÈ›ii                          O(1) operaÈ›ii*
            </div>
        </div>

        <!-- ============================================================
             SLIDE 6: STRUCTURA UNUI NODE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ§± Structura FundamentalÄƒ: Node</h1>
            <p>Un <span class="keyword">node</span> conÈ›ine douÄƒ componente esenÈ›iale:</p>
            <div class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              NODE (Nod)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       DATA        â”‚        NEXT         â”‚
â”‚    (date utile)   â”‚   (pointer cÄƒtre    â”‚
â”‚                   â”‚    nodul urmÄƒtor)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   int, float,     â”‚   struct Node*      â”‚
â”‚   char[], struct  â”‚   sau NULL          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>DefiniÈ›ia structurii Node Ã®n C</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef struct Node {
    int data;           /* Datele stocate - poate fi orice tip */
    struct Node *next;  /* Pointer cÄƒtre urmÄƒtorul nod */
} Node;</code></pre>
            </div>
            <div class="warning-box">
                <strong>âš ï¸ AtenÈ›ie:</strong> Folosim <code>struct Node *next</code> Ã®n interior deoarece <code>typedef</code> nu este Ã®ncÄƒ complet definit!
            </div>
        </div>

        <!-- ============================================================
             SLIDE 7: VIZUALIZAREA LISTEI
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ”— Vizualizarea unei Liste Simplu ÃnlÄƒnÈ›uite</h1>
            <div class="ascii-diagram">
                HEAD (capul listei)
                  â”‚
                  â–¼
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚ data: 10â”‚      â”‚ data: 20â”‚      â”‚ data: 30â”‚      â”‚ data: 40â”‚
             â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
             â”‚ next: â—â”€â”¼â”€â”€â”€â”€â”€â–ºâ”‚ next: â—â”€â”¼â”€â”€â”€â”€â”€â–ºâ”‚ next: â—â”€â”¼â”€â”€â”€â”€â”€â–ºâ”‚next:NULLâ”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                Node 1           Node 2           Node 3           Node 4
                                                                  (ultimul)
            </div>
            <div class="info-box">
                <strong>ğŸ”‘ Concepte cheie:</strong>
                <ul>
                    <li><strong>HEAD</strong> - pointer cÄƒtre primul nod (punct de intrare Ã®n listÄƒ)</li>
                    <li><strong>TAIL</strong> - ultimul nod (next = NULL)</li>
                    <li><strong>NULL</strong> - marcheazÄƒ sfÃ¢rÈ™itul listei</li>
                </ul>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 8: MALLOC È˜I FREE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ§  Gestiunea Memoriei: malloc() È™i free()</h1>
            <div class="two-columns">
                <div>
                    <h3>malloc() - Memory Allocation</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Alocarea dinamicÄƒ</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/* AlocÄƒ memorie pentru un nod */
Node *new_node = (Node *)malloc(sizeof(Node));

/* VerificÄƒ dacÄƒ alocarea a reuÈ™it */
if (new_node == NULL) {
    fprintf(stderr, "Eroare: memorie insuficientÄƒ!\n");
    exit(EXIT_FAILURE);
}

/* IniÈ›ializeazÄƒ nodul */
new_node->data = 42;
new_node->next = NULL;</code></pre>
                    </div>
                </div>
                <div>
                    <h3>free() - Eliberarea memoriei</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Eliberarea memoriei</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/* ElibereazÄƒ memoria unui nod */
free(node_ptr);

/* BunÄƒ practicÄƒ: seteazÄƒ pointerul la NULL */
node_ptr = NULL;

/* Eliberarea Ã®ntregii liste */
while (head != NULL) {
    Node *temp = head;
    head = head->next;
    free(temp);
}</code></pre>
                    </div>
                </div>
            </div>
            <div class="danger-box">
                <strong>ğŸš¨ CRITIC:</strong> Fiecare <code>malloc()</code> trebuie sÄƒ aibÄƒ un <code>free()</code> corespondent! Altfel â†’ memory leak!
            </div>
        </div>

        <!-- ============================================================
             SLIDE 9: CREAREA UNUI NODE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ”¨ FuncÈ›ie: Crearea unui Node Nou</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>FuncÈ›ie completÄƒ pentru crearea unui nod</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * CreeazÄƒ un nod nou cu valoarea specificatÄƒ.
 * 
 * @param value Valoarea de stocat Ã®n nod
 * @return Pointer cÄƒtre noul nod sau NULL dacÄƒ alocarea eÈ™ueazÄƒ
 */
Node *create_node(int value) {
    /* Pasul 1: AlocÄƒ memorie */
    Node *new_node = (Node *)malloc(sizeof(Node));
    
    /* Pasul 2: VerificÄƒ alocarea */
    if (new_node == NULL) {
        fprintf(stderr, "Eroare: malloc() a eÈ™uat!\n");
        return NULL;
    }
    
    /* Pasul 3: IniÈ›ializeazÄƒ cÃ¢mpurile */
    new_node->data = value;
    new_node->next = NULL;
    
    /* Pasul 4: ReturneazÄƒ noul nod */
    return new_node;
}</code></pre>
            </div>
            <div class="success-box">
                <strong>âœ… Bune practici:</strong> VerificÄƒ Ã®ntotdeauna valoarea returnatÄƒ de malloc(), iniÈ›ializeazÄƒ toate cÃ¢mpurile È™i returneazÄƒ NULL Ã®n caz de eroare.
            </div>
        </div>

        <!-- ============================================================
             SLIDE 10: INSERARE LA ÃNCEPUT
             ============================================================ -->
        <div class="slide">
            <h1>â¡ï¸ Inserarea la Ãnceput (Prepend)</h1>
            <div class="ascii-diagram">
ÃNAINTE:                              DUPÄ‚:
HEAD                                  HEAD
  â”‚                                     â”‚
  â–¼                                     â–¼
â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”
â”‚  B  â”‚â”€â”€â–ºâ”‚  C  â”‚â”€â”€â–ºâ”‚  D  â”‚   â”€â”€â”€â–º   â”‚  A  â”‚â”€â”€â–ºâ”‚  B  â”‚â”€â”€â–ºâ”‚  C  â”‚â”€â”€â–ºâ”‚  D  â”‚
â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜
                                       NEW
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Inserare la Ã®nceput - O(1)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * InsereazÄƒ un nod nou la Ã®nceputul listei.
 * Complexitate: O(1)
 */
void prepend(Node **head, int value) {
    /* CreeazÄƒ noul nod */
    Node *new_node = create_node(value);
    if (new_node == NULL) return;
    
    /* Noul nod pointeazÄƒ cÄƒtre fostul cap */
    new_node->next = *head;
    
    /* ActualizeazÄƒ head-ul */
    *head = new_node;
}</code></pre>
            </div>
            <div class="info-box">
                <strong>ğŸ’¡ De ce Node **head?</strong> Avem nevoie de pointer la pointer pentru a modifica valoarea lui head din funcÈ›ia apelantÄƒ!
            </div>
        </div>

        <!-- ============================================================
             SLIDE 11: INSERARE LA SFÃ‚RÈ˜IT
             ============================================================ -->
        <div class="slide">
            <h1>â¬…ï¸ Inserarea la SfÃ¢rÈ™it (Append)</h1>
            <div class="ascii-diagram">
ÃNAINTE:                              DUPÄ‚:
HEAD                    TAIL          HEAD                              TAIL
  â”‚                       â”‚             â”‚                                 â”‚
  â–¼                       â–¼             â–¼                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”
â”‚  A  â”‚â”€â”€â–ºâ”‚  B  â”‚â”€â”€â–ºâ”‚NULL â”‚   â”€â”€â”€â–º   â”‚  A  â”‚â”€â”€â–ºâ”‚  B  â”‚â”€â”€â–ºâ”‚  C  â”‚â”€â”€â–ºâ”‚NULL â”‚
â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜
                                                           NEW
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Inserare la sfÃ¢rÈ™it - O(n)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * InsereazÄƒ un nod nou la sfÃ¢rÈ™itul listei.
 * Complexitate: O(n) - trebuie sÄƒ parcurgem toatÄƒ lista
 */
void append(Node **head, int value) {
    Node *new_node = create_node(value);
    if (new_node == NULL) return;
    
    /* Caz special: lista este goalÄƒ */
    if (*head == NULL) {
        *head = new_node;
        return;
    }
    
    /* Parcurge lista pÃ¢nÄƒ la ultimul nod */
    Node *current = *head;
    while (current->next != NULL) {
        current = current->next;
    }
    
    /* AtaÈ™eazÄƒ noul nod */
    current->next = new_node;
}</code></pre>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 12: INSERARE LA POZIÈšIE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ“ Inserarea la o PoziÈ›ie SpecificatÄƒ</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Inserare la poziÈ›ia k - O(n)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * InsereazÄƒ un nod nou la poziÈ›ia specificatÄƒ (0-indexed).
 */
void insert_at(Node **head, int value, int position) {
    /* Caz special: inserare la Ã®nceput */
    if (position == 0) {
        prepend(head, value);
        return;
    }
    
    Node *new_node = create_node(value);
    if (new_node == NULL) return;
    
    /* Parcurge lista pÃ¢nÄƒ la poziÈ›ia (position - 1) */
    Node *current = *head;
    for (int i = 0; i < position - 1 && current != NULL; i++) {
        current = current->next;
    }
    
    /* VerificÄƒ dacÄƒ poziÈ›ia este validÄƒ */
    if (current == NULL) {
        fprintf(stderr, "Eroare: poziÈ›ie invalidÄƒ!\n");
        free(new_node);
        return;
    }
    
    /* InsereazÄƒ noul nod */
    new_node->next = current->next;
    current->next = new_node;
}</code></pre>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 13: TRAVERSARE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸš¶ Traversarea Listei</h1>
            <div class="two-columns">
                <div>
                    <h3>AfiÈ™are simplÄƒ</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Print list</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">void print_list(Node *head) {
    printf("Lista: ");
    Node *current = head;
    
    while (current != NULL) {
        printf("%d", current->data);
        if (current->next != NULL) {
            printf(" -> ");
        }
        current = current->next;
    }
    
    printf(" -> NULL\n");
}</code></pre>
                    </div>
                </div>
                <div>
                    <h3>NumÄƒrare elemente</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Count nodes</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">int count_nodes(Node *head) {
    int count = 0;
    Node *current = head;
    
    while (current != NULL) {
        count++;
        current = current->next;
    }
    
    return count;
}</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box">
                <strong>ğŸ“Œ Pattern de traversare:</strong> <code>Node *current = head; while (current != NULL) { /* proces */ current = current->next; }</code>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 14: CÄ‚UTARE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ” CÄƒutarea Ã®n ListÄƒ</h1>
            <div class="two-columns">
                <div>
                    <h3>CÄƒutare dupÄƒ valoare</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Find by value</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/**
 * CautÄƒ un nod dupÄƒ valoare.
 * @return Pointer cÄƒtre nod sau NULL
 */
Node *find_node(Node *head, int value) {
    Node *current = head;
    
    while (current != NULL) {
        if (current->data == value) {
            return current;
        }
        current = current->next;
    }
    
    return NULL;  /* Nu a fost gÄƒsit */
}</code></pre>
                    </div>
                </div>
                <div>
                    <h3>CÄƒutare dupÄƒ index</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Get at index</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/**
 * ReturneazÄƒ nodul de la indexul dat.
 */
Node *get_at(Node *head, int index) {
    if (index < 0) return NULL;
    
    Node *current = head;
    int i = 0;
    
    while (current != NULL && i < index) {
        current = current->next;
        i++;
    }
    
    return current;
}</code></pre>
                    </div>
                </div>
            </div>
            <div class="warning-box">
                <strong>âš ï¸ Complexitate:</strong> CÄƒutarea Ã®n linked list este O(n) - nu putem face cÄƒutare binarÄƒ!
            </div>
        </div>

        <!-- ============================================================
             SLIDE 15: È˜TERGERE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ—‘ï¸ È˜tergerea unui Node</h1>
            <div class="ascii-diagram">
È˜tergere nod cu valoarea 20:
                    
ÃNAINTE:  HEADâ†’[10]â†’[20]â†’[30]â†’NULL
                      â†“
                   DELETE
                      â†“
DUPÄ‚:     HEADâ†’[10]â”€â”€â”€â”€â†’[30]â†’NULL
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>È˜tergere nod dupÄƒ valoare</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">void delete_node(Node **head, int value) {
    if (*head == NULL) return;
    
    /* Caz special: È™tergem head-ul */
    if ((*head)->data == value) {
        Node *temp = *head;
        *head = (*head)->next;
        free(temp);
        return;
    }
    
    /* CÄƒutÄƒm nodul anterior celui de È™ters */
    Node *current = *head;
    while (current->next != NULL && current->next->data != value) {
        current = current->next;
    }
    
    /* DacÄƒ am gÄƒsit nodul */
    if (current->next != NULL) {
        Node *temp = current->next;
        current->next = temp->next;
        free(temp);
    }
}</code></pre>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 16: ELIBERAREA LISTEI
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ§¹ Eliberarea Ãntregii Liste</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Free entire list - OBLIGATORIU pentru a evita memory leaks!</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * ElibereazÄƒ toatÄƒ memoria alocatÄƒ pentru listÄƒ.
 * TREBUIE apelatÄƒ Ã®nainte de terminarea programului!
 */
void free_list(Node **head) {
    Node *current = *head;
    Node *next_node;
    
    while (current != NULL) {
        /* SalvÄƒm pointer-ul cÄƒtre urmÄƒtorul nod */
        next_node = current->next;
        
        /* EliberÄƒm nodul curent */
        free(current);
        
        /* AvansÄƒm la urmÄƒtorul nod */
        current = next_node;
    }
    
    /* SetÄƒm head la NULL pentru siguranÈ›Äƒ */
    *head = NULL;
}

/* Utilizare Ã®n main() */
int main(void) {
    Node *head = NULL;
    /* ... operaÈ›ii pe listÄƒ ... */
    
    free_list(&head);  /* OBLIGATORIU! */
    return 0;
}</code></pre>
            </div>
            <div class="danger-box">
                <strong>ğŸš¨ CRITIC:</strong> FÄƒrÄƒ <code>free_list()</code>, programul va avea memory leaks. Valgrind va detecta È™i raporta aceste probleme!
            </div>
        </div>

        <!-- ============================================================
             SLIDE 17: LISTA DUBLU ÃNLÄ‚NÈšUITÄ‚
             ============================================================ -->
        <div class="slide">
            <h1>â†”ï¸ Lista Dublu ÃnlÄƒnÈ›uitÄƒ (Doubly Linked List)</h1>
            <div class="ascii-diagram">
        HEAD                                                          TAIL
          â”‚                                                             â”‚
          â–¼                                                             â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚prev:NULLâ”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚  prev   â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚  prev   â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚  prev   â”‚
     â”‚ data: A â”‚        â”‚ data: B â”‚        â”‚ data: C â”‚        â”‚ data: D â”‚
     â”‚  next   â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚  next   â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚  next   â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚next:NULLâ”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Structura unui nod dublu Ã®nlÄƒnÈ›uit</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">typedef struct DNode {
    int data;
    struct DNode *prev;  /* Pointer cÄƒtre nodul anterior */
    struct DNode *next;  /* Pointer cÄƒtre nodul urmÄƒtor */
} DNode;

/* Structura listei cu head È™i tail */
typedef struct {
    DNode *head;
    DNode *tail;
    int size;
} DoublyLinkedList;</code></pre>
            </div>
            <div class="success-box">
                <strong>âœ… Avantaje:</strong> Navigare Ã®n ambele direcÈ›ii, È™tergere Ã®n O(1) dacÄƒ ai pointer-ul la nod, implementare undo/redo.
            </div>
        </div>

        <!-- ============================================================
             SLIDE 18: OPERAÈšII PE LISTÄ‚ DUBLÄ‚
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ”„ OperaÈ›ii pe Lista Dublu ÃnlÄƒnÈ›uitÄƒ</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Inserare È™i È™tergere Ã®n listÄƒ dublÄƒ</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Inserare la sfÃ¢rÈ™it */
void dll_append(DoublyLinkedList *list, int value) {
    DNode *new_node = (DNode *)malloc(sizeof(DNode));
    new_node->data = value;
    new_node->next = NULL;
    new_node->prev = list->tail;
    
    if (list->tail != NULL) {
        list->tail->next = new_node;
    } else {
        list->head = new_node;  /* Prima inserare */
    }
    list->tail = new_node;
    list->size++;
}

/* È˜tergere nod specific (cÃ¢nd ai pointer-ul) - O(1)! */
void dll_remove_node(DoublyLinkedList *list, DNode *node) {
    if (node->prev != NULL) node->prev->next = node->next;
    else list->head = node->next;
    
    if (node->next != NULL) node->next->prev = node->prev;
    else list->tail = node->prev;
    
    free(node);
    list->size--;
}</code></pre>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 19: LISTA CIRCULARÄ‚
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ”„ Lista CircularÄƒ</h1>
            <div class="ascii-diagram">
                                     HEAD
                                       â”‚
                                       â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”Œâ”€â”€â”€â”€â”€â”
                  â”‚                 â”‚  A  â”‚
                  â”‚                 â””â”€â”€â”¬â”€â”€â”˜
                  â”‚                    â”‚
                  â”‚                    â–¼
               â”Œâ”€â”€â”´â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”
               â”‚  D  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  B  â”‚
               â””â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”¬â”€â”€â”˜
                  â–²                    â”‚
                  â”‚                    â–¼
                  â”‚                 â”Œâ”€â”€â”€â”€â”€â”
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  C  â”‚
                                   â””â”€â”€â”€â”€â”€â”˜
            </div>
            <div class="two-columns">
                <div>
                    <h3>AplicaÈ›ii</h3>
                    <ul>
                        <li>Round-robin scheduling Ã®n SO</li>
                        <li>Playlist-uri Ã®n mod repeat</li>
                        <li>Buffer circular</li>
                        <li>Jocuri (tura jucÄƒtorilor)</li>
                    </ul>
                </div>
                <div>
                    <h3>Detectarea sfÃ¢rÈ™itului</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Traversare listÄƒ circularÄƒ</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/* Nu verificÄƒm NULL! */
Node *current = head;
do {
    /* proceseazÄƒ current */
    current = current->next;
} while (current != head);</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 20: COMPARAÈšIE TIPURI DE LISTE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ“Š ComparaÈ›ie: Tipuri de Liste</h1>
            <table>
                <tr>
                    <th>CaracteristicÄƒ</th>
                    <th>Simplu ÃnlÄƒnÈ›uitÄƒ</th>
                    <th>Dublu ÃnlÄƒnÈ›uitÄƒ</th>
                    <th>CircularÄƒ</th>
                </tr>
                <tr>
                    <td>Memorie/nod</td>
                    <td>data + 1 pointer</td>
                    <td>data + 2 pointeri</td>
                    <td>data + 1-2 pointeri</td>
                </tr>
                <tr>
                    <td>Traversare</td>
                    <td>Doar Ã®nainte</td>
                    <td>Ambele direcÈ›ii</td>
                    <td>Ciclic</td>
                </tr>
                <tr>
                    <td>Inserare la Ã®nceput</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Inserare la sfÃ¢rÈ™it</td>
                    <td>O(n)*</td>
                    <td>O(1) cu tail</td>
                    <td>O(1) cu tail</td>
                </tr>
                <tr>
                    <td>È˜tergere nod dat</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                    <td>O(1) sau O(n)</td>
                </tr>
                <tr>
                    <td>Complexitate cod</td>
                    <td>SimplÄƒ</td>
                    <td>Medie</td>
                    <td>Mai complexÄƒ</td>
                </tr>
            </table>
            <p style="margin-top: 1rem; color: var(--text-secondary);">* O(1) dacÄƒ menÈ›inem un pointer tail</p>
        </div>

        <!-- ============================================================
             SLIDE 21: COMPLEXITATE - GRAFIC
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ“ˆ Complexitate: Array vs. Linked List</h1>
            <table>
                <tr>
                    <th>OperaÈ›ie</th>
                    <th>Array</th>
                    <th>Linked List</th>
                    <th>CÃ¢È™tigÄƒtor</th>
                </tr>
                <tr>
                    <td>Acces la index[i]</td>
                    <td style="color: var(--accent-green);">O(1)</td>
                    <td style="color: var(--accent-red);">O(n)</td>
                    <td>Array</td>
                </tr>
                <tr>
                    <td>Inserare la Ã®nceput</td>
                    <td style="color: var(--accent-red);">O(n)</td>
                    <td style="color: var(--accent-green);">O(1)</td>
                    <td>Linked List</td>
                </tr>
                <tr>
                    <td>Inserare la sfÃ¢rÈ™it</td>
                    <td style="color: var(--accent-yellow);">O(1)*</td>
                    <td style="color: var(--accent-yellow);">O(1)**</td>
                    <td>Egalitate</td>
                </tr>
                <tr>
                    <td>È˜tergere la Ã®nceput</td>
                    <td style="color: var(--accent-red);">O(n)</td>
                    <td style="color: var(--accent-green);">O(1)</td>
                    <td>Linked List</td>
                </tr>
                <tr>
                    <td>CÄƒutare</td>
                    <td style="color: var(--accent-yellow);">O(n)</td>
                    <td style="color: var(--accent-yellow);">O(n)</td>
                    <td>Egalitate</td>
                </tr>
                <tr>
                    <td>Cache locality</td>
                    <td style="color: var(--accent-green);">Excelent</td>
                    <td style="color: var(--accent-red);">Slab</td>
                    <td>Array</td>
                </tr>
            </table>
            <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-secondary);">
                * Array amortizat (cu redimensionare)<br>
                ** Linked list cu pointer tail
            </p>
        </div>

        <!-- ============================================================
             SLIDE 22: MODELUL DE MEMORIE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ§  Modelul de Memorie</h1>
            <div class="ascii-diagram">
MEMORIA PROGRAMULUI:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         STACK                            â”‚  â† Variabile locale
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚     (head pointer)
â”‚  â”‚ Node *head = 0x1000                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                          HEAP                            â”‚  â† Memorie dinamicÄƒ
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚     (nodurile listei)
â”‚  â”‚ Addr: 0x1000    â”‚  â”‚ Addr: 0x2000    â”‚  â”‚ 0x3000   â”‚ â”‚
â”‚  â”‚ data: 10        â”‚  â”‚ data: 20        â”‚  â”‚ data: 30 â”‚ â”‚
â”‚  â”‚ next: 0x2000 â”€â”€â”€â”¼â”€â”€â”¼â–ºnext: 0x3000 â”€â”€â”€â”¼â”€â”€â”¼â–ºnext:NULLâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â”‚  [Memoria poate fi non-contiguÄƒ!]                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                       DATA/BSS                           â”‚  â† Variabile globale
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         CODE                             â”‚  â† Codul programului
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>
        </div>

        <!-- ============================================================
             SLIDE 23: ERORI COMUNE - PARTEA 1
             ============================================================ -->
        <div class="slide">
            <h1>âš ï¸ Erori Comune (1/2)</h1>
            <div class="two-columns">
                <div>
                    <h3>âŒ NULL Pointer Dereference</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>GREÈ˜IT</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/* Crash dacÄƒ head este NULL! */
printf("%d", head->data);</code></pre>
                    </div>
                    <div class="code-block">
                        <div class="code-header">
                            <span>CORECT</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/* VerificÄƒ Ã®ntotdeauna! */
if (head != NULL) {
    printf("%d", head->data);
}</code></pre>
                    </div>
                </div>
                <div>
                    <h3>âŒ Memory Leak</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>GREÈ˜IT</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/* Memoria se pierde! */
head = new_node;  // fÄƒrÄƒ free</code></pre>
                    </div>
                    <div class="code-block">
                        <div class="code-header">
                            <span>CORECT</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/* ElibereazÄƒ mai Ã®ntÃ¢i! */
free_list(&head);
head = new_node;</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 24: ERORI COMUNE - PARTEA 2
             ============================================================ -->
        <div class="slide">
            <h1>âš ï¸ Erori Comune (2/2)</h1>
            <div class="two-columns">
                <div>
                    <h3>âŒ Dangling Pointer</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>GREÈ˜IT</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">free(node);
/* node Ã®ncÄƒ pointeazÄƒ la 
   memorie eliberatÄƒ! */
node->data = 5;  /* CRASH! */</code></pre>
                    </div>
                    <div class="code-block">
                        <div class="code-header">
                            <span>CORECT</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">free(node);
node = NULL;  /* SiguranÈ›Äƒ */</code></pre>
                    </div>
                </div>
                <div>
                    <h3>âŒ Pierderea LegÄƒturii</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>GREÈ˜IT</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/* Inserare: pierdem restul listei! */
current->next = new_node;
/* Ce se Ã®ntÃ¢mplÄƒ cu fostul 
   current->next? PIERDUT! */</code></pre>
                    </div>
                    <div class="code-block">
                        <div class="code-header">
                            <span>CORECT</span>
                            <span class="lang-badge">C</span>
                        </div>
                        <pre><code class="language-c">/* Ordinea conteazÄƒ! */
new_node->next = current->next;
current->next = new_node;</code></pre>
                    </div>
                </div>
            </div>
            <div class="danger-box">
                <strong>ğŸ¯ RegulÄƒ de aur:</strong> La inserare, conecteazÄƒ mai Ã®ntÃ¢i noul nod la lista existentÄƒ, apoi modificÄƒ pointer-ul anterior!
            </div>
        </div>

        <!-- ============================================================
             SLIDE 25: DEBUGGING CU GDB
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ”§ Debugging: GDB pentru Liste</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Comenzi GDB utile pentru linked lists</span>
                    <span class="lang-badge">GDB</span>
                </div>
                <pre><code class="language-bash"># Compilare cu simboluri de debug
$ gcc -g -o program program.c

# Pornire GDB
$ gdb ./program

# Comenzi GDB:
(gdb) break main              # Breakpoint la main
(gdb) run                     # RuleazÄƒ programul
(gdb) print head              # AfiÈ™eazÄƒ valoarea lui head
(gdb) print *head             # DereferenÈ›iazÄƒ: afiÈ™eazÄƒ conÈ›inutul nodului
(gdb) print head->data        # AfiÈ™eazÄƒ data din head
(gdb) print head->next        # AfiÈ™eazÄƒ pointer-ul next
(gdb) print *head->next       # AfiÈ™eazÄƒ al doilea nod

# Parcurgere pas cu pas
(gdb) next                    # UrmÄƒtoarea linie
(gdb) step                    # IntrÄƒ Ã®n funcÈ›ie
(gdb) continue                # ContinuÄƒ pÃ¢nÄƒ la urmÄƒtorul breakpoint

# AfiÈ™are listÄƒ (manual)
(gdb) set $node = head
(gdb) while $node != 0
> print $node->data
> set $node = $node->next
> end</code></pre>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 26: DEBUGGING CU VALGRIND
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ” Debugging: Valgrind pentru Memory Leaks</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Utilizare Valgrind</span>
                    <span class="lang-badge">Bash</span>
                </div>
                <pre><code class="language-bash"># Verificare completÄƒ a memoriei
$ valgrind --leak-check=full --show-leak-kinds=all ./program

# Output pentru program CORECT:
==12345== HEAP SUMMARY:
==12345==   in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 5 allocs, 5 frees, 80 bytes allocated
==12345== All heap blocks were freed -- no leaks are possible

# Output pentru program CU MEMORY LEAK:
==12345== LEAK SUMMARY:
==12345==    definitely lost: 48 bytes in 3 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==    possibly lost: 0 bytes in 0 blocks
==12345== ERROR SUMMARY: 1 errors from 1 contexts</code></pre>
            </div>
            <div class="warning-box">
                <strong>ğŸ“Œ Interpretare:</strong>
                <ul>
                    <li><strong>definitely lost</strong> = memory leak sigur (trebuie reparat!)</li>
                    <li><strong>indirectly lost</strong> = memorie pierdutÄƒ prin alte leaks</li>
                    <li><strong>possibly lost</strong> = pointer-i modificaÈ›i (de investigat)</li>
                </ul>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 27: BUNE PRACTICI
             ============================================================ -->
        <div class="slide">
            <h1>âœ… Bune Practici</h1>
            <div class="two-columns">
                <div class="card">
                    <h3 style="color: var(--accent-green);">âœ“ DO (FÄƒ)</h3>
                    <ul>
                        <li>VerificÄƒ Ã®ntotdeauna returnul lui <code>malloc()</code></li>
                        <li>SeteazÄƒ pointerii la <code>NULL</code> dupÄƒ <code>free()</code></li>
                        <li>ElibereazÄƒ toatÄƒ memoria Ã®nainte de exit</li>
                        <li>FoloseÈ™te funcÈ›ii separate pentru fiecare operaÈ›ie</li>
                        <li>DocumenteazÄƒ cine este responsabil pentru eliberarea memoriei</li>
                        <li>TesteazÄƒ cu Valgrind regulat</li>
                        <li>TrateazÄƒ toate cazurile limitÄƒ (NULL, un element, etc.)</li>
                    </ul>
                </div>
                <div class="card">
                    <h3 style="color: var(--accent-red);">âœ— DON'T (Nu FÄƒ)</h3>
                    <ul>
                        <li>Nu dereferenÈ›ia un pointer fÄƒrÄƒ verificare</li>
                        <li>Nu uita sÄƒ eliberezi memoria</li>
                        <li>Nu folosi un pointer dupÄƒ <code>free()</code></li>
                        <li>Nu pierde legÄƒtura la restul listei la inserare</li>
                        <li>Nu presupune cÄƒ lista are elemente</li>
                        <li>Nu ignora warning-urile compilatorului</li>
                        <li>Nu copia cod fÄƒrÄƒ sÄƒ Ã®nÈ›elegi ce face</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 28: PATTERN - SENTINEL NODE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ’¡ Pattern Avansat: Sentinel Node</h1>
            <p>Un <span class="highlight">sentinel node</span> (nod santinelÄƒ) este un nod "fals" care simplificÄƒ codul eliminÃ¢nd cazurile speciale.</p>
            <div class="ascii-diagram">
FÄƒrÄƒ sentinel:              Cu sentinel:
HEAD â†’ poate fi NULL        HEAD â†’ SENTINEL â†’ Date reale...
(multe verificÄƒri)          (Ã®ntotdeauna existÄƒ un nod)
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Implementare cu sentinel node</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* IniÈ›ializare cu sentinel */
Node *create_list_with_sentinel(void) {
    Node *sentinel = create_node(0);  /* Valoare dummy */
    return sentinel;  /* ReturnÄƒm sentinel-ul ca head */
}

/* Inserare - nu mai verificÄƒm dacÄƒ head e NULL! */
void insert_after_sentinel(Node *sentinel, int value) {
    Node *new_node = create_node(value);
    new_node->next = sentinel->next;
    sentinel->next = new_node;
}

/* Traversare - Ã®ncepem de la sentinel->next */
void print_list_sentinel(Node *sentinel) {
    Node *current = sentinel->next;  /* SÄƒrim peste sentinel */
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}</code></pre>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 29: ALGORITM - INVERSARE LISTÄ‚
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ”„ Algoritm Classic: Inversarea Listei</h1>
            <div class="ascii-diagram">
ÃNAINTE: HEAD â†’ [A] â†’ [B] â†’ [C] â†’ [D] â†’ NULL
DUPÄ‚:    HEAD â†’ [D] â†’ [C] â†’ [B] â†’ [A] â†’ NULL
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span>Inversare in-place - O(n) timp, O(1) spaÈ›iu</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * InverseazÄƒ o listÄƒ simplu Ã®nlÄƒnÈ›uitÄƒ in-place.
 * FoloseÈ™te trei pointeri: prev, current, next
 */
void reverse_list(Node **head) {
    Node *prev = NULL;
    Node *current = *head;
    Node *next_node = NULL;
    
    while (current != NULL) {
        /* SalveazÄƒ urmÄƒtorul nod */
        next_node = current->next;
        
        /* InverseazÄƒ legÄƒtura */
        current->next = prev;
        
        /* AvanseazÄƒ pointerii */
        prev = current;
        current = next_node;
    }
    
    /* prev este acum noul head */
    *head = prev;
}</code></pre>
            </div>
            <div class="info-box">
                <strong>ğŸ“ Ãntrebare de interviu frecventÄƒ!</strong> ÃnÈ›elegeÈ›i fiecare pas È™i puteÈ›i sÄƒ Ã®l desenaÈ›i.
            </div>
        </div>

        <!-- ============================================================
             SLIDE 30: ALGORITM - DETECTARE CICLU
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ¢ğŸ‡ Algoritmul Floyd (Tortoise and Hare)</h1>
            <p>Detectarea ciclurilor Ã®n liste Ã®nlÄƒnÈ›uite folosind doi pointeri cu viteze diferite.</p>
            <div class="code-block">
                <div class="code-header">
                    <span>Detectare ciclu - O(n) timp, O(1) spaÈ›iu</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * DetecteazÄƒ dacÄƒ o listÄƒ are un ciclu.
 * Slow pointer avanseazÄƒ cu 1, fast pointer cu 2.
 * DacÄƒ existÄƒ ciclu, se vor Ã®ntÃ¢lni.
 */
int has_cycle(Node *head) {
    if (head == NULL) return 0;
    
    Node *slow = head;       /* Broasca È›estoasÄƒ ğŸ¢ */
    Node *fast = head;       /* Iepurele ğŸ‡ */
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;           /* AvanseazÄƒ cu 1 */
        fast = fast->next->next;     /* AvanseazÄƒ cu 2 */
        
        if (slow == fast) {
            return 1;  /* Ciclu detectat! */
        }
    }
    
    return 0;  /* Nu existÄƒ ciclu */
}</code></pre>
            </div>
            <div class="success-box">
                <strong>ğŸ’¡ De ce funcÈ›ioneazÄƒ?</strong> DacÄƒ existÄƒ ciclu, fast-ul va "prinde din urmÄƒ" slow-ul Ã®n interiorul ciclului.
            </div>
        </div>

        <!-- ============================================================
             SLIDE 31: ALGORITM - GÄ‚SIREA MIJLOCULUI
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ“ GÄƒsirea Mijlocului Ã®ntr-o SingurÄƒ Traversare</h1>
            <div class="code-block">
                <div class="code-header">
                    <span>Tehnica slow/fast pointer</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/**
 * GÄƒseÈ™te nodul din mijlocul listei Ã®ntr-o singurÄƒ traversare.
 * CÃ¢nd fast ajunge la final, slow este la mijloc.
 */
Node *find_middle(Node *head) {
    if (head == NULL) return NULL;
    
    Node *slow = head;
    Node *fast = head;
    
    /* fast avanseazÄƒ de 2 ori mai repede */
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;  /* slow este la mijloc */
}

/* Exemplu:
 * Lista: 1 -> 2 -> 3 -> 4 -> 5 -> NULL
 * 
 * Pas 1: slow=1, fast=1
 * Pas 2: slow=2, fast=3
 * Pas 3: slow=3, fast=5
 * fast->next este NULL, STOP
 * Rezultat: slow=3 (mijlocul)
 */</code></pre>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 32: APLICAÈšII REALE - LINUX KERNEL
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ§ AplicaÈ›ie RealÄƒ: Linux Kernel List</h1>
            <p>Kernelul Linux foloseÈ™te o implementare elegantÄƒ de liste dublu Ã®nlÄƒnÈ›uite circulare.</p>
            <div class="code-block">
                <div class="code-header">
                    <span>Simplificarea listei din Linux (include/linux/list.h)</span>
                    <span class="lang-badge">C</span>
                </div>
                <pre><code class="language-c">/* Structura listei - doar pointerii! */
struct list_head {
    struct list_head *next, *prev;
};

/* Se include Ã®n orice structurÄƒ */
struct my_data {
    int value;
    char name[64];
    struct list_head list;  /* Link cÄƒtre alte elemente */
};

/* Macro magic pentru a obÈ›ine structura pÄƒrinte */
#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - offsetof(type, member)))

#define list_entry(ptr, type, member) \
    container_of(ptr, type, member)

/* Utilizare */
struct my_data *item = list_entry(ptr, struct my_data, list);</code></pre>
            </div>
            <div class="info-box">
                <strong>ğŸ’¡ Avantaj:</strong> O singurÄƒ implementare de listÄƒ pentru toate structurile de date din kernel!
            </div>
        </div>

        <!-- ============================================================
             SLIDE 33: PREVIZUALIZARE LABORATOR
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ”¬ Previzualizare Laborator</h1>
            <div class="two-columns">
                <div class="card">
                    <div class="card-title">ğŸ“‹ ExerciÈ›iul 1: Lista de StudenÈ›i</div>
                    <p>ImplementaÈ›i o listÄƒ simplu Ã®nlÄƒnÈ›uitÄƒ pentru gestionarea datelor studenÈ›ilor:</p>
                    <ul>
                        <li>StructurÄƒ Student: id, nume, medie</li>
                        <li>Creare, inserare, cÄƒutare</li>
                        <li>È˜tergere dupÄƒ id</li>
                        <li>Sortare dupÄƒ medie</li>
                        <li>Salvare/Ã®ncÄƒrcare din fiÈ™ier</li>
                    </ul>
                    <p><strong>8 TODO-uri</strong></p>
                </div>
                <div class="card">
                    <div class="card-title">ğŸµ ExerciÈ›iul 2: Playlist Muzical</div>
                    <p>ImplementaÈ›i o listÄƒ dublu Ã®nlÄƒnÈ›uitÄƒ pentru un player muzical:</p>
                    <ul>
                        <li>StructurÄƒ Melodie: titlu, artist, duratÄƒ</li>
                        <li>Navigare: next, prev, start, end</li>
                        <li>Inserare sortatÄƒ</li>
                        <li>Mod shuffle</li>
                        <li>Calculare duratÄƒ totalÄƒ</li>
                    </ul>
                    <p><strong>10 TODO-uri</strong></p>
                </div>
            </div>
            <div class="success-box">
                <strong>ğŸ¯ Obiectiv:</strong> Aplicarea practicÄƒ a conceptelor teoretice Ã®n scenarii realiste.
            </div>
        </div>

        <!-- ============================================================
             SLIDE 34: REZUMAT
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ“ Rezumat</h1>
            <div class="summary-grid">
                <div class="summary-box">
                    <div class="icon">ğŸ§±</div>
                    <h3>Node</h3>
                    <p>data + pointer next</p>
                    <p class="label">Unitatea fundamentalÄƒ</p>
                </div>
                <div class="summary-box">
                    <div class="icon">ğŸ“</div>
                    <h3>HEAD</h3>
                    <p>Punctul de intrare</p>
                    <p class="label">Pointer cÄƒtre primul nod</p>
                </div>
                <div class="summary-box">
                    <div class="icon">â¡ï¸</div>
                    <h3>Inserare O(1)</h3>
                    <p>La Ã®nceput</p>
                    <p class="label">Prepend</p>
                </div>
                <div class="summary-box">
                    <div class="icon">ğŸ”</div>
                    <h3>CÄƒutare O(n)</h3>
                    <p>Traversare liniarÄƒ</p>
                    <p class="label">Nu suportÄƒ cÄƒutare binarÄƒ</p>
                </div>
                <div class="summary-box">
                    <div class="icon">ğŸ§ </div>
                    <h3>malloc/free</h3>
                    <p>Gestiunea memoriei</p>
                    <p class="label">EvitÄƒ memory leaks!</p>
                </div>
                <div class="summary-box">
                    <div class="icon">â†”ï¸</div>
                    <h3>Dublu ÃnlÄƒnÈ›uitÄƒ</h3>
                    <p>prev + next</p>
                    <p class="label">Navigare bidirecÈ›ionalÄƒ</p>
                </div>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 35: RESURSE
             ============================================================ -->
        <div class="slide">
            <h1>ğŸ“š Resurse Recomandate</h1>
            <div class="two-columns">
                <div>
                    <h3>CÄƒrÈ›i</h3>
                    <ul>
                        <li><strong>K&R</strong> - The C Programming Language (Cap. 6)</li>
                        <li><strong>Sedgewick</strong> - Algorithms (SecÈ›. 1.3)</li>
                        <li><strong>CLRS</strong> - Introduction to Algorithms (Cap. 10)</li>
                        <li><strong>Knuth</strong> - TAOCP Vol. 1</li>
                    </ul>
                    <h3>Online</h3>
                    <ul>
                        <li>Stanford CS Library - Linked List Basics</li>
                        <li>GeeksforGeeks - Data Structures</li>
                        <li>Visualgo.net - VizualizÄƒri interactive</li>
                    </ul>
                </div>
                <div>
                    <h3>PracticÄƒ</h3>
                    <ul>
                        <li><strong>LeetCode</strong> - Linked List problems</li>
                        <li><strong>HackerRank</strong> - Data Structures track</li>
                        <li><strong>Exercism</strong> - C track</li>
                    </ul>
                    <h3>Tools</h3>
                    <ul>
                        <li><strong>Valgrind</strong> - Memory checking</li>
                        <li><strong>GDB</strong> - Debugging</li>
                        <li><strong>AddressSanitizer</strong> - Runtime checking</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- ============================================================
             SLIDE 36: ÃNTREBÄ‚RI
             ============================================================ -->
        <div class="slide title-slide">
            <div class="emoji-large">â“</div>
            <h1>ÃntrebÄƒri?</h1>
            <p class="subtitle">DiscuÈ›ie È™i clarificÄƒri</p>
            <div style="margin-top: 3rem;">
                <p class="meta">
                    <strong>SÄƒptÄƒmÃ¢na urmÄƒtoare:</strong><br>
                    ğŸ“š Stive (Stacks) - LIFO, push, pop, aplicaÈ›ii
                </p>
            </div>
        </div>

    </div>

    <!-- Navigation -->
    <div class="navigation">
        <button class="nav-btn" onclick="goToSlide(0)" title="Prima">â®</button>
        <button class="nav-btn" onclick="previousSlide()" title="Anterior">â—€</button>
        <button class="nav-btn" onclick="nextSlide()" title="UrmÄƒtor">â–¶</button>
        <button class="nav-btn" onclick="goToSlide(totalSlides - 1)" title="Ultima">â­</button>
    </div>

    <!-- Slide Counter -->
    <div class="slide-counter">
        <span id="currentSlide">1</span> / <span id="totalSlides">36</span>
    </div>

    <script>
        // IniÈ›ializare
        let currentSlideIndex = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        
        document.getElementById('totalSlides').textContent = totalSlides;
        
        // Highlight.js
        hljs.highlightAll();
        
        // FuncÈ›ii de navigare
        function showSlide(index) {
            slides.forEach(slide => slide.classList.remove('active'));
            slides[index].classList.add('active');
            document.getElementById('currentSlide').textContent = index + 1;
            updateProgressBar();
        }
        
        function nextSlide() {
            if (currentSlideIndex < totalSlides - 1) {
                currentSlideIndex++;
                showSlide(currentSlideIndex);
            }
        }
        
        function previousSlide() {
            if (currentSlideIndex > 0) {
                currentSlideIndex--;
                showSlide(currentSlideIndex);
            }
        }
        
        function goToSlide(index) {
            if (index >= 0 && index < totalSlides) {
                currentSlideIndex = index;
                showSlide(currentSlideIndex);
            }
        }
        
        function updateProgressBar() {
            const progress = ((currentSlideIndex + 1) / totalSlides) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }
        
        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    previousSlide();
                    break;
                case 'Home':
                    e.preventDefault();
                    goToSlide(0);
                    break;
                case 'End':
                    e.preventDefault();
                    goToSlide(totalSlides - 1);
                    break;
            }
        });
        
        // IniÈ›ializare progress bar
        updateProgressBar();
    </script>
</body>
</html>
